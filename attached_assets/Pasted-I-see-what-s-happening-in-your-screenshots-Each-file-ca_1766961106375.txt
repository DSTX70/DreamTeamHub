I see what’s happening in your screenshots:

* ✅ Each file card shows **OK**
* ❌ The **content panes are blank**

That pattern almost always means **the upstream payload has file entries, but the content field name doesn’t match what the DTH UI is reading** (e.g., upstream returns `content` or `text`, UI is reading `contents`, etc.). So the UI renders “OK” but `value=""`.

### Fix (no schema changes): normalize the upstream response in the DTH proxy

We’ll make the DreamTeamHub proxy **always return `files[]` with BOTH `contents` and `content` populated**, regardless of what GigsterGarage called it.

---

## DROP B — DreamTeamHub (apply manually)

**Repo:** `DreamTeamHub`
**Replace file:** `server/routes/connectors/gigsterGarage.route.ts`

```ts
FILE: server/routes/connectors/gigsterGarage.route.ts
import express, { Request, Response } from "express";

const router = express.Router();

/**
 * Route-local body parsing (robust against missing/wrong Content-Type)
 * - Try express.json for real JSON requests
 * - Fallback to express.text and attempt JSON.parse or treat as newline pathsText
 */
const jsonParser = express.json({
  limit: "2mb",
  type: ["application/json", "application/*+json"],
});

const textParser = express.text({
  limit: "2mb",
  type: "*/*",
});

function routeBodyParser(req: Request, res: Response, next: (err?: any) => void) {
  jsonParser(req, res, (err) => {
    if (err) return next(err);

    // If jsonParser ran and produced an object, we're done.
    if (req.body && typeof req.body === "object") return next();

    // Otherwise fallback to text parsing.
    textParser(req, res, (err2) => {
      if (err2) return next(err2);

      if (typeof req.body === "string") {
        const raw = req.body.trim();

        // If it looks like JSON, try parsing; otherwise treat as newline list.
        if (raw.startsWith("{") || raw.startsWith("[")) {
          try {
            req.body = JSON.parse(raw);
          } catch {
            req.body = { pathsText: req.body };
          }
        } else {
          req.body = { pathsText: req.body };
        }
      }

      return next();
    });
  });
}

type ParsedPathsResult = { paths: string[]; source: string };

function parsePaths(body: any): ParsedPathsResult {
  if (!body) return { paths: [], source: "none" };

  // Allow raw string body to be treated as pathsText
  if (typeof body === "string") {
    const split = body
      .split(/\r?\n/)
      .map((s) => s.trim())
      .filter(Boolean);
    return { paths: split, source: "raw-string" };
  }

  // { paths: ["a","b"] }
  if (Array.isArray(body.paths)) {
    return {
      paths: body.paths.map(String).map((s) => s.trim()).filter(Boolean),
      source: "paths[]",
    };
  }

  // { paths: "a\nb" } OR { pathsText: "a\nb" } OR { paths_string: "a\nb" }
  const raw =
    typeof body.paths === "string"
      ? body.paths
      : typeof body.pathsText === "string"
        ? body.pathsText
        : typeof body.paths_string === "string"
          ? body.paths_string
          : undefined;

  if (typeof raw === "string") {
    const split = raw
      .split(/\r?\n/)
      .map((s) => s.trim())
      .filter(Boolean);
    return {
      paths: split,
      source: typeof body.paths === "string" ? "paths:string" : "pathsText",
    };
  }

  return { paths: [], source: "unknown" };
}

function envOrThrow(key: string): string {
  const v = process.env[key];
  if (!v) throw new Error(`Missing env var ${key}`);
  return v;
}

function baseUrl(url: string): string {
  return url.replace(/\/+$/, "");
}

function safeKeys(x: any): string[] {
  if (!x || typeof x !== "object") return [];
  return Object.keys(x);
}

function tryDecodeBase64(s: string): string | null {
  try {
    // Heuristic: if it decodes cleanly and contains mostly printable chars, accept it.
    const buf = Buffer.from(s, "base64");
    const out = buf.toString("utf8");
    // If decoding gives lots of replacement chars, reject.
    const bad = (out.match(/\uFFFD/g) || []).length;
    if (bad > 3) return null;
    return out;
  } catch {
    return null;
  }
}

function pickContentField(obj: any): { text: string; from: string } {
  const candidates: Array<[string, any]> = [
    ["contents", obj?.contents],
    ["content", obj?.content],
    ["text", obj?.text],
    ["body", obj?.body],
    ["data", obj?.data],
    ["source", obj?.source],
    ["raw", obj?.raw],
  ];

  for (const [k, v] of candidates) {
    if (typeof v === "string") return { text: v, from: k };
  }

  // base64 variants
  const b64Candidates: Array<[string, any]> = [
    ["contentBase64", obj?.contentBase64],
    ["contentsBase64", obj?.contentsBase64],
    ["base64", obj?.base64],
    ["b64", obj?.b64],
  ];
  for (const [k, v] of b64Candidates) {
    if (typeof v === "string") {
      const decoded = tryDecodeBase64(v);
      if (decoded != null) return { text: decoded, from: `${k}:decoded` };
    }
  }

  return { text: "", from: "none" };
}

function pickPathField(obj: any, fallbackPath?: string): string {
  const candidates: any[] = [obj?.path, obj?.filePath, obj?.filepath, obj?.name, fallbackPath];
  for (const v of candidates) {
    if (typeof v === "string" && v.trim()) return v.trim();
  }
  return "";
}

type NormalizedFile = {
  path: string;
  ok: boolean;
  error?: string;
  contents: string;
  content: string;
  _contentFrom?: string;
  _contentLen?: number;
  _keys?: string[];
  [k: string]: any;
};

function normalizeUpstreamPayload(payload: any) {
  // Identify a list of file-ish items
  let items: any[] = [];
  let normalizedFrom = "unknown";

  if (Array.isArray(payload?.files)) {
    items = payload.files;
    normalizedFrom = "payload.files[]";
  } else if (Array.isArray(payload?.results)) {
    items = payload.results;
    normalizedFrom = "payload.results[]";
  } else if (payload?.files && typeof payload.files === "object") {
    // files: { "path": "content" }
    items = Object.entries(payload.files).map(([path, v]) => ({ path, content: v }));
    normalizedFrom = "payload.files:map";
  } else if (payload?.data && typeof payload.data === "object" && !Array.isArray(payload.data)) {
    // data: { "path": "content" }
    items = Object.entries(payload.data).map(([path, v]) => ({ path, content: v }));
    normalizedFrom = "payload.data:map";
  } else if (Array.isArray(payload)) {
    items = payload;
    normalizedFrom = "payload:array";
  }

  const files: NormalizedFile[] = items.map((it) => {
    const path = pickPathField(it);
    const ok = typeof it?.ok === "boolean" ? it.ok : true;
    const error = typeof it?.error === "string" ? it.error : undefined;

    const picked = pickContentField(it);
    const contents = picked.text ?? "";
    const file: NormalizedFile = {
      ...it,
      path,
      ok,
      error,
      // Provide BOTH keys to satisfy whichever the UI expects
      contents,
      content: contents,
      _contentFrom: picked.from,
      _contentLen: contents.length,
      _keys: safeKeys(it),
    };

    return file;
  });

  const topOk = typeof payload?.ok === "boolean" ? payload.ok : true;

  return {
    ok: topOk,
    files,
    // extra aliases for compatibility
    results: files,
    _meta: {
      normalized: true,
      normalizedFrom,
      upstreamTopKeys: safeKeys(payload),
      fileCount: files.length,
      nonEmptyCount: files.filter((f) => (f.contents || "").length > 0).length,
      sample: files.slice(0, 3).map((f) => ({
        path: f.path,
        ok: f.ok,
        contentLen: f._contentLen,
        contentFrom: f._contentFrom,
      })),
    },
  };
}

/**
 * DEBUG: proves what DTH parsed from the request body
 * POST /api/connectors/gigsterGarage/echo
 */
router.post("/echo", routeBodyParser, (req: Request, res: Response) => {
  const parsed = parsePaths(req.body);

  res.json({
    ok: true,
    where: "DreamTeamHub",
    contentType: req.headers["content-type"] ?? null,
    bodyType: typeof req.body,
    bodyKeys: req.body && typeof req.body === "object" ? Object.keys(req.body) : null,
    parsedSource: parsed.source,
    parsedPathsCount: parsed.paths.length,
    parsedPaths: parsed.paths,
  });
});

/**
 * Read-only proxy to GigsterGarage:
 * POST /api/connectors/gigsterGarage/files
 */
router.post("/files", routeBodyParser, async (req: Request, res: Response) => {
  try {
    const parsed = parsePaths(req.body);

    if (!parsed.paths.length) {
      return res.status(400).json({
        ok: false,
        where: "DreamTeamHub",
        error: "paths[] required",
        hint:
          'Send JSON: { "paths": ["client/src/hooks/useAuth.ts", "..."] } OR { "pathsText": "path1\\npath2" }',
        received: {
          contentType: req.headers["content-type"] ?? null,
          bodyType: typeof req.body,
          bodyKeys: req.body && typeof req.body === "object" ? Object.keys(req.body) : null,
          parsedSource: parsed.source,
        },
      });
    }

    const ggBase = baseUrl(envOrThrow("GIGSTER_GARAGE_BASE_URL"));
    const token = envOrThrow("GIGSTER_GARAGE_READONLY_TOKEN");

    const upstreamUrl = `${ggBase}/api/dth/files`;

    // Force upstream to receive proper JSON no matter what came in.
    const upstreamRes = await fetch(upstreamUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        "x-dth-token": token,
      },
      body: JSON.stringify({ paths: parsed.paths }),
    });

    const ct = upstreamRes.headers.get("content-type") || "";
    const text = await upstreamRes.text();

    // Bubble upstream errors with useful diagnostics (no secrets).
    if (!upstreamRes.ok) {
      let upstreamJson: any = null;
      if (ct.includes("application/json")) {
        try {
          upstreamJson = JSON.parse(text);
        } catch {
          // ignore
        }
      }

      return res.status(upstreamRes.status).json({
        ok: false,
        where: "DreamTeamHub",
        error: "Upstream error",
        upstream: {
          status: upstreamRes.status,
          contentType: ct || null,
          json: upstreamJson,
          textSnippet: upstreamJson ? undefined : text.slice(0, 900),
        },
      });
    }

    // Successful upstream response — normalize to ensure UI sees contents.
    if (ct.includes("application/json")) {
      try {
        const upstreamJson = JSON.parse(text);
        const normalized = normalizeUpstreamPayload(upstreamJson);
        return res.json(normalized);
      } catch {
        // fallthrough
      }
    }

    return res.status(502).json({
      ok: false,
      where: "DreamTeamHub",
      error: "Upstream returned non-JSON",
      upstream: {
        status: upstreamRes.status,
        contentType: ct || null,
        textSnippet: text.slice(0, 900),
      },
    });
  } catch (err: any) {
    return res.status(500).json({
      ok: false,
      where: "DreamTeamHub",
      error: err?.message || "Unknown error",
    });
  }
});

export default router;
END_FILE
```

---

## Retest (what you should see now)

Go back to `/connectors/gigsterGarage` → **Fetch files**.

Even if the UI is reading `content` *or* `contents`, it should now populate.
If it *still* looks blank, the normalized response will include:

* `_meta.nonEmptyCount`
* `_meta.sample[].contentLen`

So we’ll immediately know whether:

* **content is present but UI styling is hiding it**, or
* **GigsterGarage truly isn’t returning any content** (contentLen = 0)

---

## One quick diagnostic (no new UI patch needed)

In browser console on DreamTeamHub:

```js
fetch("/api/connectors/gigsterGarage/files", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ paths: [
    "client/src/hooks/useAuth.ts",
    "client/src/lib/queryClient.ts",
    "server/routes.ts"
  ]}),
}).then(r => r.json()).then(console.log);
```

If `_meta.nonEmptyCount` is **3**, we’re good and the UI just needs styling.
If it’s **0**, then GigsterGarage is returning entries without content and we patch that next.

Once you paste the console JSON (just the `_meta` block is enough), I’ll immediately ship the next drop (either **DTH UI styling** or **GigsterGarage route-local parser/return content**), and then we move into **Pilot C**.
