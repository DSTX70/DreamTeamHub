Perfect — this is exactly the missing piece. ✅
With this list, we can make **Curated-Cast deterministic** (non-generic *and* machine-actionable) by using **stable slugs** instead of display names.

Also: your list reveals **three duplicate identity pairs** that will absolutely cause drift unless we normalize them.

---

## 1) Immediate Audit Findings (from your list)

### ✅ Core Dream Team (56)

You have **duplicate slugs for the same persona** (canonicalization needed):

* `agent_app_dev_guru` **and** `agent_app_development_guru`
* `agent_izumi` **and** `agent_izumi_takahashi`
* `agent_kaoru` **and** `agent_kaoru_arai`

**Recommendation (low-risk):**

* Pick ONE canonical slug for each pair (I recommend the more explicit one):

  * `agent_app_development_guru`
  * `agent_izumi_takahashi`
  * `agent_kaoru_arai`
* Keep the short versions as **aliases** (redirect mapping), not separate identities.

This will prevent:

* two “different” people appearing in Curated-Cast
* split analytics / history
* routing ambiguity

---

## 2) What we should do in the UI now

Right now Curated-Cast stores human-readable selections in the Cast Receipt.

We upgrade it to store BOTH:

* **Display label** (nice for humans)
* **Slug** (stable for routing)

Example receipt:

```
Cast Receipt
Mode: CURATED
Pods:
  - pod: Dream Team | slug: dream_team
Personas:
  - name: Izumi Takahashi | slug: agent_izumi_takahashi
  - name: Kaoru Arai | slug: agent_kaoru_arai
Autonomy: STANDARD
```

This is how we keep the “curated orchestra” behavior **without** exposing the entire system everywhere.

---

## 3) Patch: Upgrade Curated-Cast to use slugs (Option B)

**Repo:** `DreamTeamHub`
This patch is safe even if your `/api/roles` endpoint returns strings or objects — it normalizes either way.

### What it changes

* `useCastOptions()` now supports:

  * arrays of strings
  * arrays of objects
  * object wrappers `{ roles: [...] }`, `{ pods: [...] }`, `{ data: [...] }`
* Intent Console stores:

  * curated slugs into Cast Receipt (and keeps display labels)

> Paste this as a follow-up patch drop:

```tsx
FILE: client/src/hooks/useCastOptions.ts
import { useQuery } from "@tanstack/react-query";

type AnyObj = Record<string, any>;
export type CastOption = { slug: string; label: string };

async function safeFetchJSON(url: string): Promise<any | null> {
  try {
    const res = await fetch(url, { credentials: "include" });
    if (!res.ok) return null;
    return await res.json();
  } catch {
    return null;
  }
}

function pickList(data: any, keys: string[]): any[] {
  if (Array.isArray(data)) return data;
  for (const k of keys) {
    if (Array.isArray(data?.[k])) return data[k];
  }
  return [];
}

function toOption(item: any): CastOption | null {
  // String list support (slug-only)
  if (typeof item === "string" && item.trim()) {
    const slug = item.trim();
    return { slug, label: slug };
  }

  // Object support
  if (item && typeof item === "object") {
    const obj = item as AnyObj;
    const slug =
      (typeof obj.slug === "string" && obj.slug.trim()) ? obj.slug.trim() :
      (typeof obj.handle === "string" && obj.handle.trim()) ? obj.handle.trim() :
      (typeof obj.id === "string" && obj.id.trim()) ? obj.id.trim() :
      null;

    const label =
      (typeof obj.name === "string" && obj.name.trim()) ? obj.name.trim() :
      (typeof obj.title === "string" && obj.title.trim()) ? obj.title.trim() :
      (typeof obj.label === "string" && obj.label.trim()) ? obj.label.trim() :
      (typeof slug === "string" ? slug : null);

    if (!slug || !label) return null;
    return { slug, label };
  }

  return null;
}

function normalizeOptions(list: any[]): CastOption[] {
  const out: CastOption[] = [];
  for (const it of list) {
    const opt = toOption(it);
    if (opt) out.push(opt);
  }
  // de-dupe by slug
  const map = new Map<string, CastOption>();
  for (const o of out) map.set(o.slug, o);
  return Array.from(map.values()).sort((a, b) => a.label.localeCompare(b.label));
}

/**
 * Best-effort discovery of pods/personas.
 * Accepts multiple API shapes; falls back to manual entry if unavailable.
 */
export function useCastOptions() {
  const podsQ = useQuery({
    queryKey: ["/api/pods"],
    queryFn: async () => {
      const data = await safeFetchJSON("/api/pods");
      if (!data) return { ok: false as const, options: [] as CastOption[] };
      const list = pickList(data, ["pods", "data", "rows"]);
      const options = normalizeOptions(list);
      return { ok: options.length > 0, options };
    },
    staleTime: 60_000,
    retry: false,
  });

  const personasQ = useQuery({
    queryKey: ["/api/roles"],
    queryFn: async () => {
      const data = await safeFetchJSON("/api/roles");
      if (!data) return { ok: false as const, options: [] as CastOption[] };
      const list = pickList(data, ["roles", "agents", "data", "rows"]);
      const options = normalizeOptions(list);
      return { ok: options.length > 0, options };
    },
    staleTime: 60_000,
    retry: false,
  });

  return {
    pods: podsQ.data?.options ?? [],
    podsOk: podsQ.data?.ok ?? false,
    podsLoading: podsQ.isLoading,
    personas: personasQ.data?.options ?? [],
    personasOk: personasQ.data?.ok ?? false,
    personasLoading: personasQ.isLoading,
  };
}
END_FILE

FILE: client/src/pages/intent-console.tsx
import { useMemo, useState } from "react";
import { useMutation } from "@tanstack/react-query";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useLocation } from "wouter";
import { Target, Users, Wand2, X, Search } from "lucide-react";
import { useCastingPrefs } from "@/hooks/useCastingPrefs";
import { useCastOptions, CastOption } from "@/hooks/useCastOptions";

type Autonomy = "guided" | "standard" | "autonomous";

function buildTitle(intent: string): string {
  const clean = intent.trim().replace(/\s+/g, " ");
  if (!clean) return "New work item";
  return clean.length <= 80 ? clean : `${clean.slice(0, 77)}...`;
}

function normalizeManualSlugs(raw: string): string[] {
  return raw
    .split(",")
    .map((x) => x.trim())
    .filter(Boolean);
}

function optionLabelBySlug(options: CastOption[], slug: string): string {
  const hit = options.find((o) => o.slug === slug);
  return hit?.label ?? slug;
}

function formatCastReceipt(params: {
  mode: "auto" | "curated";
  podSlugs: string[];
  personaSlugs: string[];
  podOptions: CastOption[];
  personaOptions: CastOption[];
  autonomy: string;
}) {
  const { mode, podSlugs, personaSlugs, podOptions, personaOptions, autonomy } = params;

  const lines: string[] = [];
  lines.push("Cast Receipt");
  lines.push(`Mode: ${mode.toUpperCase()}`);
  lines.push(`Autonomy: ${autonomy.toUpperCase()}`);

  lines.push("Pods:");
  if (mode === "auto" || podSlugs.length === 0) {
    lines.push("  - AUTO");
  } else {
    for (const s of podSlugs) {
      lines.push(`  - name: ${optionLabelBySlug(podOptions, s)} | slug: ${s}`);
    }
  }

  lines.push("Personas:");
  if (mode === "auto" || personaSlugs.length === 0) {
    lines.push("  - AUTO");
  } else {
    for (const s of personaSlugs) {
      lines.push(`  - name: ${optionLabelBySlug(personaOptions, s)} | slug: ${s}`);
    }
  }

  return lines.join("\n");
}

function toggleInList(list: string[], value: string): string[] {
  const v = value.trim();
  if (!v) return list;
  return list.includes(v) ? list.filter((x) => x !== v) : [...list, v];
}

export default function IntentConsolePage() {
  const [intent, setIntent] = useState("");
  const [autonomy, setAutonomy] = useState<Autonomy>("standard");
  const { toast } = useToast();
  const [, setLocation] = useLocation();

  const { mode, setMode, pods, setPods, personas, setPersonas } = useCastingPrefs();
  const { pods: podOptions, podsOk, podsLoading, personas: personaOptions, personasOk, personasLoading } = useCastOptions();

  const [podFilter, setPodFilter] = useState("");
  const [personaFilter, setPersonaFilter] = useState("");
  const [manualPods, setManualPods] = useState("");
  const [manualPersonas, setManualPersonas] = useState("");

  const title = useMemo(() => buildTitle(intent), [intent]);

  const effectivePodSlugs = useMemo(() => {
    if (mode !== "curated") return [];
    if (podsOk) return pods; // stored slugs
    return normalizeManualSlugs(manualPods);
  }, [mode, podsOk, pods, manualPods]);

  const effectivePersonaSlugs = useMemo(() => {
    if (mode !== "curated") return [];
    if (personasOk) return personas; // stored slugs
    return normalizeManualSlugs(manualPersonas);
  }, [mode, personasOk, personas, manualPersonas]);

  const filteredPodOptions = useMemo(() => {
    const q = podFilter.trim().toLowerCase();
    if (!q) return podOptions;
    return podOptions.filter((p) => p.label.toLowerCase().includes(q) || p.slug.toLowerCase().includes(q));
  }, [podOptions, podFilter]);

  const filteredPersonaOptions = useMemo(() => {
    const q = personaFilter.trim().toLowerCase();
    if (!q) return personaOptions;
    return personaOptions.filter((p) => p.label.toLowerCase().includes(q) || p.slug.toLowerCase().includes(q));
  }, [personaOptions, personaFilter]);

  const createMutation = useMutation({
    mutationFn: async () => {
      const castReceipt = formatCastReceipt({
        mode,
        podSlugs: effectivePodSlugs,
        personaSlugs: effectivePersonaSlugs,
        podOptions,
        personaOptions,
        autonomy,
      });

      const payload = {
        title,
        description:
          (intent
            ? `Intent: ${intent.trim()}\n\n`
            : "") +
          `Autonomy: ${autonomy.toUpperCase()}\n\n---\n${castReceipt}\n---\n`,
        status: "todo",
        priority: "medium",
      };

      return apiRequest("POST", "/api/work-items", payload);
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["/api/work-items"] });
      await queryClient.invalidateQueries({ queryKey: ["/api/control/dashboard"] });
      toast({
        title: "Queued",
        description:
          mode === "curated"
            ? "Your intent + curated cast (slugs) were converted into a governed work item."
            : "Your intent was converted into a governed work item.",
      });
      setIntent("");
      setLocation("/work-orders");
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Could not create a work item from that intent.",
        variant: "destructive",
      });
    },
  });

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl font-semibold mb-2" data-testid="page-title">
          Intent
        </h1>
        <p className="text-sm text-muted-foreground">
          Auto-Cast chooses the cast. Curated-Cast lets you select pods/personas by stable slug for deterministic routing.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Target className="h-5 w-5" />
            What are you trying to accomplish?
          </CardTitle>
          <CardDescription>Outcome-first. Curate the cast when you want unique, non-generic results.</CardDescription>
        </CardHeader>

        <CardContent className="space-y-5">
          <div className="space-y-2">
            <label className="text-sm font-medium">Intent</label>
            <Textarea
              value={intent}
              onChange={(e) => setIntent(e.target.value)}
              placeholder="e.g., Run an IP + security + UX synthesis on this feature change."
              className="min-h-32"
              data-testid="intent-textarea"
            />
          </div>

          <div className="grid gap-4 md:grid-cols-2">
            <div className="space-y-2">
              <label className="text-sm font-medium">Autonomy</label>
              <Select value={autonomy} onValueChange={(v) => setAutonomy(v as Autonomy)}>
                <SelectTrigger data-testid="intent-autonomy">
                  <SelectValue placeholder="Select" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="guided">Guided</SelectItem>
                  <SelectItem value="standard">Standard</SelectItem>
                  <SelectItem value="autonomous">Autonomous</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <label className="text-sm font-medium">Casting</label>
              <div className="flex gap-2">
                <Button
                  type="button"
                  variant={mode === "auto" ? "default" : "outline"}
                  size="sm"
                  className="gap-2"
                  onClick={() => setMode("auto")}
                  data-testid="cast-auto"
                >
                  <Wand2 className="h-4 w-4" />
                  Auto-Cast
                </Button>
                <Button
                  type="button"
                  variant={mode === "curated" ? "default" : "outline"}
                  size="sm"
                  className="gap-2"
                  onClick={() => setMode("curated")}
                  data-testid="cast-curated"
                >
                  <Users className="h-4 w-4" />
                  Curated-Cast
                </Button>
              </div>
              <p className="text-xs text-muted-foreground">
                Curated-Cast stores stable slugs in the Cast Receipt to keep routing deterministic.
              </p>
            </div>
          </div>

          {mode === "curated" && (
            <div className="rounded-lg border p-4 space-y-4" data-testid="curated-panel">
              <div className="flex items-start justify-between gap-4">
                <div>
                  <div className="font-medium">Curated Cast (by slug)</div>
                  <div className="text-xs text-muted-foreground">
                    Select from discovered options, or enter comma-separated slugs if endpoints are unavailable.
                  </div>
                </div>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    setPods([]);
                    setPersonas([]);
                    setManualPods("");
                    setManualPersonas("");
                  }}
                  className="gap-2"
                  data-testid="cast-clear"
                >
                  <X className="h-4 w-4" />
                  Clear
                </Button>
              </div>

              {/* Pods */}
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-medium">Pods</label>
                  <span className="text-xs text-muted-foreground">Selected: {effectivePodSlugs.length}</span>
                </div>

                {podsOk ? (
                  <>
                    <div className="flex items-center gap-2">
                      <Search className="h-4 w-4 text-muted-foreground" />
                      <Input
                        value={podFilter}
                        onChange={(e) => setPodFilter(e.target.value)}
                        placeholder={podsLoading ? "Loading…" : "Filter by label or slug…"}
                        data-testid="pods-filter"
                      />
                    </div>

                    <div className="flex flex-wrap gap-2">
                      {filteredPodOptions.slice(0, 80).map((o) => {
                        const selected = effectivePodSlugs.includes(o.slug);
                        return (
                          <Badge
                            key={o.slug}
                            variant={selected ? "default" : "secondary"}
                            className="cursor-pointer select-none"
                            onClick={() => setPods(toggleInList(pods, o.slug))}
                            title={o.slug}
                            data-testid={`pod-${o.slug}`}
                          >
                            {o.label}
                          </Badge>
                        );
                      })}
                    </div>
                  </>
                ) : (
                  <>
                    <p className="text-xs text-muted-foreground">
                      Pod endpoint not detected. Enter pod slugs manually.
                    </p>
                    <Input
                      value={manualPods}
                      onChange={(e) => setManualPods(e.target.value)}
                      placeholder="e.g., pod_marketing, pod_ip, pod_security"
                      data-testid="pods-manual"
                    />
                  </>
                )}
              </div>

              {/* Personas */}
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-medium">Personas</label>
                  <span className="text-xs text-muted-foreground">Selected: {effectivePersonaSlugs.length}</span>
                </div>

                {personasOk ? (
                  <>
                    <div className="flex items-center gap-2">
                      <Search className="h-4 w-4 text-muted-foreground" />
                      <Input
                        value={personaFilter}
                        onChange={(e) => setPersonaFilter(e.target.value)}
                        placeholder={personasLoading ? "Loading…" : "Filter by label or slug…"}
                        data-testid="personas-filter"
                      />
                    </div>

                    <div className="flex flex-wrap gap-2">
                      {filteredPersonaOptions.slice(0, 120).map((o) => {
                        const selected = effectivePersonaSlugs.includes(o.slug);
                        return (
                          <Badge
                            key={o.slug}
                            variant={selected ? "default" : "secondary"}
                            className="cursor-pointer select-none"
                            onClick={() => setPersonas(toggleInList(personas, o.slug))}
                            title={o.slug}
                            data-testid={`persona-${o.slug}`}
                          >
                            {o.label}
                          </Badge>
                        );
                      })}
                    </div>
                  </>
                ) : (
                  <>
                    <p className="text-xs text-muted-foreground">
                      Persona endpoint not detected. Enter persona slugs manually (you pasted the canonical list — use those).
                    </p>
                    <Input
                      value={manualPersonas}
                      onChange={(e) => setManualPersonas(e.target.value)}
                      placeholder="e.g., agent_aegis, agent_sentinel, agent_prism"
                      data-testid="personas-manual"
                    />
                  </>
                )}
              </div>
            </div>
          )}

          <div className="flex items-center gap-3">
            <Button
              onClick={() => createMutation.mutate()}
              disabled={!intent.trim() || createMutation.isPending}
              data-testid="intent-submit"
            >
              Create Work Item
            </Button>
            <Button variant="outline" onClick={() => setLocation("/work-orders")} data-testid="intent-go-work">
              Go to Work
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
END_FILE
```

---

## 4) One more thing: your canonical list should become the fallback options (no API dependency)

Right now, if `/api/roles` isn’t returning those slugs, the UI will still work via manual entry.

If you want the **chips** to show even without a roles API, we can add a zero-backend fallback:

* Create `client/src/lib/canonAgents.ts` with your list
* `useCastOptions()` uses it when endpoint missing

If you say “**Add canon fallback chips**”, I’ll ship that patch next.

---

## Post-apply verification

1. `npm run check`
2. `npm run dev`
3. `/intent` → Curated-Cast → select a few personas
4. Create work item → confirm Cast Receipt includes `slug:` lines

---

### Quick question (only for the alias cleanup)

For the 3 duplicate pairs, confirm which slugs you want as canonical:

* App Dev Guru: `agent_app_development_guru` (recommended) or `agent_app_dev_guru`
* Izumi: `agent_izumi_takahashi` (recommended) or `agent_izumi`
* Kaoru: `agent_kaoru_arai` (recommended) or `agent_kaoru`

If you don’t answer, I’ll proceed with the recommended canon and treat the shorter ones as aliases in the next patch.
