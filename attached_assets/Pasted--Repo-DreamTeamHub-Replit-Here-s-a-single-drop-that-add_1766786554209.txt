**Repo:** `DreamTeamHub` (Replit)
Here’s a **single drop** that adds a curated `canonPods.ts` fallback (only the pods we actually want selectable in Curated-Cast), and wires it into `useCastOptions()` so **Pods chips always populate** even if `/api/pods` is missing or returns an unexpected shape.

I’m intentionally keeping the fallback pod list **tight + outcome-aligned** (not “every internal pod concept”):

* **OS / System** (Helm / orchestration)
* **Product + UX**
* **Engineering**
* **Brand + Marketing**
* **Narrative + PR**
* **IP / Legal**
* **Security / Risk**
* **Evidence / QA**
* **Ops / Delivery**
* **Medical** (because you actively use it)

You can rename/expand later, but this prevents the UI from exploding.

---

```tsx
FILE: client/src/lib/canonPods.ts
/**
 * Canonical fallback list of selectable pods for Curated-Cast.
 * Intentionally curated to avoid exposing every internal construct.
 *
 * These are "user-meaningful" pods that map to outcomes and real workflows.
 */

export type CanonPod = { slug: string; label: string };

export const CANON_PODS: CanonPod[] = [
  { slug: "pod_os", label: "OS / System" },
  { slug: "pod_product_ux", label: "Product + UX" },
  { slug: "pod_engineering", label: "Engineering" },
  { slug: "pod_brand_marketing", label: "Brand + Marketing" },
  { slug: "pod_narrative_pr", label: "Narrative + PR" },
  { slug: "pod_ip_legal", label: "IP / Legal" },
  { slug: "pod_security_risk", label: "Security / Risk" },
  { slug: "pod_evidence_qa", label: "Evidence / QA" },
  { slug: "pod_ops_delivery", label: "Ops / Delivery" },
  { slug: "pod_medical", label: "Medical" },
];

export function canonPodsAsOptions() {
  return CANON_PODS.map((p) => ({ slug: p.slug, label: p.label }));
}
END_FILE

FILE: client/src/hooks/useCastOptions.ts
import { useQuery } from "@tanstack/react-query";
import { canonAgentsAsOptions } from "@/lib/canonAgents";
import { canonPodsAsOptions } from "@/lib/canonPods";

type AnyObj = Record<string, any>;
export type CastOption = { slug: string; label: string };

async function safeFetchJSON(url: string): Promise<any | null> {
  try {
    const res = await fetch(url, { credentials: "include" });
    if (!res.ok) return null;
    return await res.json();
  } catch {
    return null;
  }
}

function pickList(data: any, keys: string[]): any[] {
  if (Array.isArray(data)) return data;
  for (const k of keys) {
    if (Array.isArray(data?.[k])) return data[k];
  }
  return [];
}

function toOption(item: any): CastOption | null {
  if (typeof item === "string" && item.trim()) {
    const slug = item.trim();
    return { slug, label: slug };
  }
  if (item && typeof item === "object") {
    const obj = item as AnyObj;
    const slug =
      (typeof obj.slug === "string" && obj.slug.trim()) ? obj.slug.trim() :
      (typeof obj.handle === "string" && obj.handle.trim()) ? obj.handle.trim() :
      (typeof obj.id === "string" && obj.id.trim()) ? obj.id.trim() :
      null;

    const label =
      (typeof obj.name === "string" && obj.name.trim()) ? obj.name.trim() :
      (typeof obj.title === "string" && obj.title.trim()) ? obj.title.trim() :
      (typeof obj.label === "string" && obj.label.trim()) ? obj.label.trim() :
      (typeof slug === "string" ? slug : null);

    if (!slug || !label) return null;
    return { slug, label };
  }
  return null;
}

function normalizeOptions(list: any[]): CastOption[] {
  const out: CastOption[] = [];
  for (const it of list || []) {
    const opt = toOption(it);
    if (opt) out.push(opt);
  }
  const map = new Map<string, CastOption>();
  for (const o of out) map.set(o.slug, o);
  return Array.from(map.values()).sort((a, b) => a.label.localeCompare(b.label));
}

/**
 * Best-effort discovery of pods/personas.
 * - Pods: tries /api/pods, falls back to curated canonPods.ts if empty/unavailable
 * - Personas: tries /api/roles, falls back to canonAgents.ts if empty/unavailable
 */
export function useCastOptions() {
  const podsQ = useQuery({
    queryKey: ["/api/pods"],
    queryFn: async () => {
      const data = await safeFetchJSON("/api/pods");
      if (!data) {
        const fallback = canonPodsAsOptions();
        return { ok: true as const, options: fallback };
      }
      const list = pickList(data, ["pods", "data", "rows"]);
      const options = normalizeOptions(list);
      if (options.length === 0) {
        const fallback = canonPodsAsOptions();
        return { ok: true as const, options: fallback };
      }
      return { ok: true as const, options };
    },
    staleTime: 60_000,
    retry: false,
  });

  const personasQ = useQuery({
    queryKey: ["/api/roles"],
    queryFn: async () => {
      const data = await safeFetchJSON("/api/roles");
      if (!data) {
        const fallback = canonAgentsAsOptions();
        return { ok: true as const, options: fallback };
      }

      const list = pickList(data, ["roles", "agents", "data", "rows"]);
      const options = normalizeOptions(list);

      if (options.length === 0) {
        const fallback = canonAgentsAsOptions();
        return { ok: true as const, options: fallback };
      }

      return { ok: true as const, options };
    },
    staleTime: 60_000,
    retry: false,
  });

  return {
    pods: podsQ.data?.options ?? [],
    podsOk: podsQ.data?.ok ?? false,
    podsLoading: podsQ.isLoading,
    personas: personasQ.data?.options ?? [],
    personasOk: personasQ.data?.ok ?? false,
    personasLoading: personasQ.isLoading,
  };
}
END_FILE
```

---

## Post-apply verification

1. `npm run check`
2. `npm run dev`
3. `/intent` → Curated-Cast → **Pods chips** should always appear (your curated list), even if `/api/pods` fails.

---

## Tiny note (so this stays clean)

These fallback pod slugs (`pod_os`, `pod_product_ux`, etc.) are **UI-level curated pods**. They don’t have to match your internal DB pod IDs yet. Later, we can add a server-side resolver that maps these curated pod slugs → real internal pods/personas during routing.
