Perfect — you already found the **canonical source of truth**:

✅ **`shared/schema.ts`**

* `export const insertWorkItemSchema = ...` (input contract)
* `export type InsertWorkItem = z.infer<typeof insertWorkItemSchema>` (what the client should send)
* `export type WorkItem = typeof workItems.$inferSelect` (what the server returns)

So you don’t need to “get the schema from Replit” anymore — you **already have it** in-repo.

### Where to open it (exactly)

In Replit, open:

* `shared/schema.ts` around **~1040–1080**

You’ll see the exact allowed fields for `createWorkItem()` because it’s built from the DB table via `createInsertSchema(workItems)` and then extended.

---

# Next: Ship the Repo/Context selector into `/intent` (using your schema safely)

Because we haven’t added a dedicated `targetContext` column to `workItems` yet (and we don’t need to), the safest move is:

✅ **Store Target Context in the Work Item `description`** inside the Cast Receipt block
→ This requires **zero schema changes** and won’t break anything.

Below is a **single Option B patch drop** for **DreamTeamHub** that:

* Adds a **Target Context selector** to `/intent`
* Persists it (localStorage)
* Writes it into the Cast Receipt as `Target Context: ...`
* Uses your full list of contexts

---

## ✅ Single Patch Drop (DreamTeamHub): Context Selector for Intent Console

```tsx
FILE: client/src/lib/contextPrefs.ts
const KEY = "dth_target_context";

export const DEFAULT_CONTEXT = "DreamTeamHub";

export const CONTEXT_OPTIONS: string[] = [
  "DreamTeamHub",
  "VSuiteHQ",
  "GigsterGarage",
  "DriveSteward",
  "Artistic Notations",
  "WaySage",
  "If When Always",
  "Parallax Translate",
  "i3 Broadcast Hub",
  "Shared Retail Shell",
  "The Fabulous Brand Company",
  "Symbioso IP Studio",
  "Verbixel Image and Copy Generator",
  "iCadence",
  "dreamshitter.com",
  "Fab Card Co",
  "fabulousAF",
];

export function getTargetContext(): string {
  try {
    const v = window.localStorage.getItem(KEY);
    return v && v.trim() ? v : DEFAULT_CONTEXT;
  } catch {
    return DEFAULT_CONTEXT;
  }
}

export function setTargetContext(next: string): void {
  try {
    window.localStorage.setItem(KEY, next);
    window.dispatchEvent(new Event("storage"));
  } catch {
    // ignore
  }
}
END_FILE

FILE: client/src/hooks/useTargetContext.ts
import { useEffect, useState } from "react";
import { CONTEXT_OPTIONS, DEFAULT_CONTEXT, getTargetContext, setTargetContext as persist } from "@/lib/contextPrefs";

export function useTargetContext() {
  const [targetContext, setTargetContextState] = useState<string>(() => getTargetContext());

  useEffect(() => {
    const onStorage = () => setTargetContextState(getTargetContext());
    window.addEventListener("storage", onStorage);
    return () => window.removeEventListener("storage", onStorage);
  }, []);

  const setTargetContext = (next: string) => {
    const safe = CONTEXT_OPTIONS.includes(next) ? next : DEFAULT_CONTEXT;
    setTargetContextState(safe);
    persist(safe);
  };

  return { targetContext, setTargetContext, contextOptions: CONTEXT_OPTIONS };
}
END_FILE

FILE: client/src/pages/intent-console.tsx
import { useMemo, useState } from "react";
import { useMutation } from "@tanstack/react-query";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useLocation } from "wouter";
import { Target, Users, Wand2, X, Search } from "lucide-react";
import { useCastingPrefs } from "@/hooks/useCastingPrefs";
import { useCastOptions, CastOption } from "@/hooks/useCastOptions";
import { dedupeCanonSlugs, toCanonSlug } from "@/lib/canonSlugMap";
import { useTargetContext } from "@/hooks/useTargetContext";

type Autonomy = "guided" | "standard" | "autonomous";

function buildTitle(intent: string): string {
  const clean = intent.trim().replace(/\s+/g, " ");
  if (!clean) return "New work item";
  return clean.length <= 80 ? clean : `${clean.slice(0, 77)}...`;
}

function normalizeManualSlugs(raw: string): string[] {
  return raw
    .split(",")
    .map((x) => x.trim())
    .filter(Boolean);
}

function optionLabelBySlug(options: CastOption[], slug: string): string {
  const canon = toCanonSlug(slug);
  const hit = options.find((o) => o.slug === canon) || options.find((o) => o.slug === slug);
  return hit?.label ?? canon ?? slug;
}

function formatCastReceipt(params: {
  mode: "auto" | "curated";
  targetContext: string;
  podSlugs: string[];
  personaSlugs: string[];
  podOptions: CastOption[];
  personaOptions: CastOption[];
  autonomy: string;
}) {
  const { mode, targetContext, podSlugs, personaSlugs, podOptions, personaOptions, autonomy } = params;

  const lines: string[] = [];
  lines.push("Cast Receipt");
  lines.push(`Mode: ${mode.toUpperCase()}`);
  lines.push(`Autonomy: ${autonomy.toUpperCase()}`);
  lines.push(`Target Context: ${targetContext}`);

  lines.push("Pods:");
  if (mode === "auto" || podSlugs.length === 0) {
    lines.push("  - AUTO");
  } else {
    for (const s of podSlugs) {
      const canon = toCanonSlug(s);
      lines.push(`  - name: ${optionLabelBySlug(podOptions, canon)} | slug: ${canon}`);
    }
  }

  lines.push("Personas:");
  if (mode === "auto" || personaSlugs.length === 0) {
    lines.push("  - AUTO");
  } else {
    for (const s of personaSlugs) {
      const canon = toCanonSlug(s);
      lines.push(`  - name: ${optionLabelBySlug(personaOptions, canon)} | slug: ${canon}`);
    }
  }

  return lines.join("\n");
}

function toggleInListCanon(list: string[], value: string): string[] {
  const canon = toCanonSlug(value.trim());
  if (!canon) return list;
  return list.includes(canon) ? list.filter((x) => x !== canon) : [...list, canon];
}

export default function IntentConsolePage() {
  const [intent, setIntent] = useState("");
  const [autonomy, setAutonomy] = useState<Autonomy>("standard");
  const { toast } = useToast();
  const [, setLocation] = useLocation();

  const { targetContext, setTargetContext, contextOptions } = useTargetContext();
  const { mode, setMode, pods, setPods, personas, setPersonas } = useCastingPrefs();
  const { pods: podOptions, podsOk, podsLoading, personas: personaOptions, personasOk, personasLoading } = useCastOptions();

  const [podFilter, setPodFilter] = useState("");
  const [personaFilter, setPersonaFilter] = useState("");
  const [manualPods, setManualPods] = useState("");
  const [manualPersonas, setManualPersonas] = useState("");

  const title = useMemo(() => buildTitle(intent), [intent]);

  const effectivePodSlugs = useMemo(() => {
    if (mode !== "curated") return [];
    const raw = podsOk ? pods : normalizeManualSlugs(manualPods);
    return dedupeCanonSlugs(raw);
  }, [mode, podsOk, pods, manualPods]);

  const effectivePersonaSlugs = useMemo(() => {
    if (mode !== "curated") return [];
    const raw = personasOk ? personas : normalizeManualSlugs(manualPersonas);
    return dedupeCanonSlugs(raw);
  }, [mode, personasOk, personas, manualPersonas]);

  const filteredPodOptions = useMemo(() => {
    const q = podFilter.trim().toLowerCase();
    if (!q) return podOptions;
    return podOptions.filter((p) => p.label.toLowerCase().includes(q) || p.slug.toLowerCase().includes(q));
  }, [podOptions, podFilter]);

  const filteredPersonaOptions = useMemo(() => {
    const q = personaFilter.trim().toLowerCase();
    if (!q) return personaOptions;
    return personaOptions.filter((p) => p.label.toLowerCase().includes(q) || p.slug.toLowerCase().includes(q));
  }, [personaOptions, personaFilter]);

  const createMutation = useMutation({
    mutationFn: async () => {
      const castReceipt = formatCastReceipt({
        mode,
        targetContext,
        podSlugs: effectivePodSlugs,
        personaSlugs: effectivePersonaSlugs,
        podOptions,
        personaOptions,
        autonomy,
      });

      const payload = {
        title,
        description:
          (intent ? `Intent: ${intent.trim()}\n\n` : "") +
          `Autonomy: ${autonomy.toUpperCase()}\n\n---\n${castReceipt}\n---\n`,
        status: "todo",
        priority: "medium",
      };

      return apiRequest("POST", "/api/work-items", payload);
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["/api/work-items"] });
      await queryClient.invalidateQueries({ queryKey: ["/api/control/dashboard"] });
      toast({
        title: "Queued",
        description:
          mode === "curated"
            ? "Your intent + curated cast + target context were converted into a governed work item."
            : "Your intent + target context were converted into a governed work item.",
      });
      setIntent("");
      setLocation("/work-orders");
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Could not create a work item from that intent.",
        variant: "destructive",
      });
    },
  });

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl font-semibold mb-2" data-testid="page-title">
          Intent
        </h1>
        <p className="text-sm text-muted-foreground">
          Choose a Target Context (repo/app), then Auto-Cast or Curated-Cast. The work item stores the full receipt for deterministic routing.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Target className="h-5 w-5" />
            What are you trying to accomplish?
          </CardTitle>
          <CardDescription>Outcome-first. Add context + cast when you want unique, non-generic results.</CardDescription>
        </CardHeader>

        <CardContent className="space-y-5">
          <div className="grid gap-4 md:grid-cols-2">
            <div className="space-y-2">
              <label className="text-sm font-medium">Target Context</label>
              <Select value={targetContext} onValueChange={setTargetContext}>
                <SelectTrigger data-testid="intent-target-context">
                  <SelectValue placeholder="Select target…" />
                </SelectTrigger>
                <SelectContent>
                  {contextOptions.map((c) => (
                    <SelectItem key={c} value={c}>
                      {c}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <p className="text-xs text-muted-foreground">
                This tells downstream shipping/verification where the work should land.
              </p>
            </div>

            <div className="space-y-2">
              <label className="text-sm font-medium">Autonomy</label>
              <Select value={autonomy} onValueChange={(v) => setAutonomy(v as Autonomy)}>
                <SelectTrigger data-testid="intent-autonomy">
                  <SelectValue placeholder="Select" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="guided">Guided</SelectItem>
                  <SelectItem value="standard">Standard</SelectItem>
                  <SelectItem value="autonomous">Autonomous</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>

          <div className="space-y-2">
            <label className="text-sm font-medium">Intent</label>
            <Textarea
              value={intent}
              onChange={(e) => setIntent(e.target.value)}
              placeholder="e.g., Add Pro route gating and streamline default workflow."
              className="min-h-32"
              data-testid="intent-textarea"
            />
          </div>

          <div className="space-y-2">
            <label className="text-sm font-medium">Casting</label>
            <div className="flex gap-2">
              <Button
                type="button"
                variant={mode === "auto" ? "default" : "outline"}
                size="sm"
                className="gap-2"
                onClick={() => setMode("auto")}
                data-testid="cast-auto"
              >
                <Wand2 className="h-4 w-4" />
                Auto-Cast
              </Button>
              <Button
                type="button"
                variant={mode === "curated" ? "default" : "outline"}
                size="sm"
                className="gap-2"
                onClick={() => setMode("curated")}
                data-testid="cast-curated"
              >
                <Users className="h-4 w-4" />
                Curated-Cast
              </Button>
            </div>
          </div>

          {mode === "curated" && (
            <div className="rounded-lg border p-4 space-y-4" data-testid="curated-panel">
              <div className="flex items-start justify-between gap-4">
                <div>
                  <div className="font-medium">Curated Cast (canonical slugs)</div>
                  <div className="text-xs text-muted-foreground">
                    Your selections + Target Context are written into the work item receipt.
                  </div>
                </div>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    setPods([]);
                    setPersonas([]);
                    setManualPods("");
                    setManualPersonas("");
                  }}
                  className="gap-2"
                  data-testid="cast-clear"
                >
                  <X className="h-4 w-4" />
                  Clear
                </Button>
              </div>

              {/* Pods */}
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-medium">Pods</label>
                  <span className="text-xs text-muted-foreground">Selected: {effectivePodSlugs.length}</span>
                </div>

                {podsOk ? (
                  <>
                    <div className="flex items-center gap-2">
                      <Search className="h-4 w-4 text-muted-foreground" />
                      <Input
                        value={podFilter}
                        onChange={(e) => setPodFilter(e.target.value)}
                        placeholder={podsLoading ? "Loading…" : "Filter by label or slug…"}
                        data-testid="pods-filter"
                      />
                    </div>

                    <div className="flex flex-wrap gap-2">
                      {filteredPodOptions.slice(0, 80).map((o) => {
                        const canon = toCanonSlug(o.slug);
                        const selected = effectivePodSlugs.includes(canon);
                        return (
                          <Badge
                            key={o.slug}
                            variant={selected ? "default" : "secondary"}
                            className="cursor-pointer select-none"
                            onClick={() => setPods(toggleInListCanon(pods, o.slug))}
                            title={`slug: ${o.slug}${canon !== o.slug ? ` → canon: ${canon}` : ""}`}
                            data-testid={`pod-${o.slug}`}
                          >
                            {o.label}
                          </Badge>
                        );
                      })}
                    </div>
                  </>
                ) : (
                  <Input
                    value={manualPods}
                    onChange={(e) => setManualPods(e.target.value)}
                    placeholder="Comma-separated pod slugs…"
                    data-testid="pods-manual"
                  />
                )}
              </div>

              {/* Personas */}
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-medium">Personas</label>
                  <span className="text-xs text-muted-foreground">Selected: {effectivePersonaSlugs.length}</span>
                </div>

                {personasOk ? (
                  <>
                    <div className="flex items-center gap-2">
                      <Search className="h-4 w-4 text-muted-foreground" />
                      <Input
                        value={personaFilter}
                        onChange={(e) => setPersonaFilter(e.target.value)}
                        placeholder={personasLoading ? "Loading…" : "Filter by label or slug…"}
                        data-testid="personas-filter"
                      />
                    </div>

                    <div className="flex flex-wrap gap-2">
                      {filteredPersonaOptions.slice(0, 120).map((o) => {
                        const canon = toCanonSlug(o.slug);
                        const selected = effectivePersonaSlugs.includes(canon);
                        return (
                          <Badge
                            key={o.slug}
                            variant={selected ? "default" : "secondary"}
                            className="cursor-pointer select-none"
                            onClick={() => setPersonas(toggleInListCanon(personas, o.slug))}
                            title={`slug: ${o.slug}${canon !== o.slug ? ` → canon: ${canon}` : ""}`}
                            data-testid={`persona-${o.slug}`}
                          >
                            {o.label}
                          </Badge>
                        );
                      })}
                    </div>
                  </>
                ) : (
                  <Input
                    value={manualPersonas}
                    onChange={(e) => setManualPersonas(e.target.value)}
                    placeholder="Comma-separated persona slugs…"
                    data-testid="personas-manual"
                  />
                )}
              </div>
            </div>
          )}

          <div className="flex items-center gap-3">
            <Button
              onClick={() => createMutation.mutate()}
              disabled={!intent.trim() || createMutation.isPending}
              data-testid="intent-submit"
            >
              Create Work Item
            </Button>
            <Button variant="outline" onClick={() => setLocation("/work-orders")} data-testid="intent-go-work">
              Go to Work
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
END_FILE
```

---

## Post-apply verification

1. `npm run check`
2. `npm run dev`
3. `/intent` → confirm Target Context dropdown appears and persists
4. Create Work Item → open it → confirm Cast Receipt includes `Target Context: ...`

---

## One important note from your grep output

You mentioned: `ops/AltTextImport.tsx` has a **local interface WorkItem (shadow)**.

That can cause subtle bugs (type drift) and “why is this different?” issues.
When you’re ready, I’ll ship a tiny cleanup patch to:

* remove the local `interface WorkItem`
* import `WorkItem` from `@shared/schema` instead

Just say: **“Unshadow WorkItem in AltTextImport”**.
