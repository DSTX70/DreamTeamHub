**Repo:** `DreamTeamHub` (Replit)
Here’s a **single-file patch drop** to polish **Work Item Detail** by surfacing **Target Context + Cast Receipt** as a first-class panel (instead of burying it inside the description).

This patch:

* Parses the work item `description` for the `---` block containing **“Cast Receipt”**
* Extracts:

  * Target Context
  * Mode
  * Autonomy
  * Pods (name + slug lines)
  * Personas (name + slug lines)
* Renders a **“Routing & Cast”** card near the top of the detail page

> If no Cast Receipt exists, the panel simply won’t render.

---

```tsx
FILE: client/src/pages/work-item-detail.tsx
import { useMemo } from "react";
import { useRoute } from "wouter";
import { useQuery } from "@tanstack/react-query";
import type { WorkItem } from "@shared/schema";
import { apiRequest } from "@/lib/queryClient";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Route, Compass, Users } from "lucide-react";

// NOTE: keep any of your existing imports below this line if they exist in your file.
// If this file already imports Card/Badge/Separator etc., dedupe imports after pasting.

type CastLine = { name: string; slug: string };

function extractCastReceiptBlock(description?: string | null): string | null {
  if (!description) return null;
  // Find a block delimited by --- that contains "Cast Receipt"
  // e.g. ...\n---\nCast Receipt\n...\n---\n
  const re = /---\s*\n([\s\S]*?)\n---/g;
  let m: RegExpExecArray | null;
  while ((m = re.exec(description)) !== null) {
    const block = m[1]?.trim();
    if (block && /(^|\n)Cast Receipt(\n|$)/i.test(block)) return block;
  }
  return null;
}

function parseKeyLine(block: string, key: string): string | null {
  const re = new RegExp(`^${key}\\s*:\\s*(.+)$`, "im");
  const m = block.match(re);
  return m?.[1]?.trim() ?? null;
}

function parseSectionLines(block: string, section: "Pods" | "Personas"): CastLine[] {
  // Supports both:
  //  - name: X | slug: Y
  //  - AUTO
  //  - (blank)
  const lines = block.split("\n").map((l) => l.trim());
  const idx = lines.findIndex((l) => l.toLowerCase() === `${section.toLowerCase()}:`);
  if (idx === -1) return [];

  const out: CastLine[] = [];
  for (let i = idx + 1; i < lines.length; i++) {
    const l = lines[i];
    if (!l) continue;

    // stop when next section starts
    if (/^(pods|personas)\s*:\s*$/i.test(l)) break;

    if (l === "-" || l.startsWith("---")) continue;
    if (/^-?\s*auto$/i.test(l.replace(/^-\s*/, ""))) {
      // Represent AUTO as empty list; caller can show "AUTO"
      return [];
    }

    // Example: "- name: Izumi Takahashi | slug: agent_izumi_takahashi"
    const nameMatch = l.match(/name\s*:\s*([^|]+)\|/i);
    const slugMatch = l.match(/slug\s*:\s*([A-Za-z0-9._-]+)/i);

    const name = nameMatch?.[1]?.trim() ?? "";
    const slug = slugMatch?.[1]?.trim() ?? "";

    if (name || slug) out.push({ name: name || slug, slug: slug || name });
  }
  return out;
}

function parseCastReceipt(description?: string | null) {
  const block = extractCastReceiptBlock(description);
  if (!block) return null;

  const targetContext = parseKeyLine(block, "Target Context");
  const mode = parseKeyLine(block, "Mode");
  const autonomy = parseKeyLine(block, "Autonomy");

  const pods = parseSectionLines(block, "Pods");
  const personas = parseSectionLines(block, "Personas");

  return {
    raw: block,
    targetContext: targetContext ?? "—",
    mode: mode ?? "—",
    autonomy: autonomy ?? "—",
    pods,
    personas,
    podsAuto: /(^|\n)Pods:\s*\n\s*-\s*AUTO(\n|$)/i.test(block) || /(^|\n)Pods:\s*\n\s*AUTO(\n|$)/i.test(block),
    personasAuto:
      /(^|\n)Personas:\s*\n\s*-\s*AUTO(\n|$)/i.test(block) || /(^|\n)Personas:\s*\n\s*AUTO(\n|$)/i.test(block),
  };
}

export default function WorkItemDetail() {
  const [match, params] = useRoute("/work-items/:id");
  const id = params?.id ? Number(params.id) : NaN;

  const { data: workItem, isLoading, error } = useQuery<WorkItem>({
    queryKey: ["/api/work-items", id],
    queryFn: async () => {
      const res = await apiRequest("GET", `/api/work-items/${id}`);
      return (await res.json()) as WorkItem;
    },
    enabled: Number.isFinite(id),
  });

  const cast = useMemo(() => parseCastReceipt(workItem?.description ?? null), [workItem?.description]);

  if (!match) return null;

  if (isLoading) {
    return (
      <div className="space-y-4">
        <div className="text-sm text-muted-foreground">Loading…</div>
      </div>
    );
  }

  if (error || !workItem) {
    return (
      <div className="space-y-4">
        <div className="text-sm text-muted-foreground">Could not load work item.</div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Title */}
      <div>
        <h1 className="text-2xl font-semibold" data-testid="work-item-title">
          {workItem.title}
        </h1>
        <div className="mt-2 flex flex-wrap gap-2">
          {workItem.status && <Badge variant="secondary">{workItem.status}</Badge>}
          {workItem.priority && <Badge variant="outline">{workItem.priority}</Badge>}
        </div>
      </div>

      {/* NEW: Routing & Cast panel */}
      {cast && (
        <Card data-testid="routing-cast-panel">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Route className="h-5 w-5" />
              Routing & Cast
            </CardTitle>
            <CardDescription>
              Target context and cast receipt (Auto or Curated). This keeps routing deterministic and outputs non-generic.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid gap-3 md:grid-cols-3">
              <div className="rounded-md border p-3">
                <div className="text-xs text-muted-foreground">Target Context</div>
                <div className="mt-1 font-medium">{cast.targetContext}</div>
              </div>
              <div className="rounded-md border p-3">
                <div className="text-xs text-muted-foreground">Mode</div>
                <div className="mt-1 font-medium">{cast.mode}</div>
              </div>
              <div className="rounded-md border p-3">
                <div className="text-xs text-muted-foreground">Autonomy</div>
                <div className="mt-1 font-medium">{cast.autonomy}</div>
              </div>
            </div>

            <Separator />

            <div className="grid gap-6 md:grid-cols-2">
              <div>
                <div className="flex items-center gap-2 mb-2">
                  <Compass className="h-4 w-4" />
                  <div className="font-medium">Pods</div>
                </div>
                {cast.podsAuto && <div className="text-sm text-muted-foreground">AUTO</div>}
                {!cast.podsAuto && cast.pods.length === 0 && (
                  <div className="text-sm text-muted-foreground">—</div>
                )}
                <div className="flex flex-wrap gap-2">
                  {cast.pods.map((p) => (
                    <Badge key={`${p.slug}-${p.name}`} variant="secondary" title={p.slug}>
                      {p.name}
                    </Badge>
                  ))}
                </div>
              </div>

              <div>
                <div className="flex items-center gap-2 mb-2">
                  <Users className="h-4 w-4" />
                  <div className="font-medium">Personas</div>
                </div>
                {cast.personasAuto && <div className="text-sm text-muted-foreground">AUTO</div>}
                {!cast.personasAuto && cast.personas.length === 0 && (
                  <div className="text-sm text-muted-foreground">—</div>
                )}
                <div className="flex flex-wrap gap-2">
                  {cast.personas.map((p) => (
                    <Badge key={`${p.slug}-${p.name}`} variant="outline" title={p.slug}>
                      {p.name}
                    </Badge>
                  ))}
                </div>
              </div>
            </div>

            <details className="text-sm">
              <summary className="cursor-pointer text-muted-foreground">View raw Cast Receipt</summary>
              <pre className="mt-2 whitespace-pre-wrap rounded-md border bg-muted/40 p-3 text-xs">
                {cast.raw}
              </pre>
            </details>
          </CardContent>
        </Card>
      )}

      {/* Existing description/content section */}
      <Card>
        <CardHeader>
          <CardTitle>Description</CardTitle>
          <CardDescription>Full work item description (includes any receipts and notes).</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="whitespace-pre-wrap text-sm" data-testid="work-item-description">
            {workItem.description || "—"}
          </div>
        </CardContent>
      </Card>

      {/* Keep the rest of your existing WorkItemDetail UI below (actions, packs, files, etc.) */}
    </div>
  );
}
END_FILE
```

---

## Post-apply verification

1. `npm run check`
2. Open a work item created from `/intent`
3. Confirm the **Routing & Cast** panel shows:

* Target Context
* Mode / Autonomy
* Pods & Personas badges
* Raw receipt collapsible

---

### If this conflicts with your existing WorkItemDetail layout

If `work-item-detail.tsx` already has lots of additional panels (actions, packs, files), paste its current contents and I’ll produce a minimal diff-style drop that inserts this panel without replacing structure.
