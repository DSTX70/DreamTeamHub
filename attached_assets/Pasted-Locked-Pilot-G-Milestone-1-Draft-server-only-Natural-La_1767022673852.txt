Locked. **Pilot G — Milestone 1 (Draft) = server-only “Natural Language Intake → Draft Intent + Strategy + Evidence Request” action** inside **DreamTeamHub**.

This ships a new Work Item Action endpoint that takes your natural-language task and returns:

* `intentBlock` (formal, structured)
* `strategyBlock` (formal, structured)
* `fileFetchPaths[]` (best-guess, whitelisted)
* `evidenceRequest` (the *single* highest-value thing to paste)
* `meta` (confidence + assumptions)

✅ No auto-apply
✅ No VSuiteHQ push
✅ No DB/schema migrations
✅ Works with your existing `runSkill()` + provider stack

---

# DROP — DreamTeamHub (manual apply)

## 1) Zod schema for the draft output

```ts
FILE: server/ai/schemas/intentStrategyDraft.ts
import { z } from "zod";

export const IntentStrategyDraftSchema = z.object({
  repo: z.string().min(1),
  intentBlock: z.string().min(1),
  strategyBlock: z.string().min(1),
  evidenceRequest: z.string().min(1),

  // Best-guess file paths for connector fetch. Must be relative paths.
  fileFetchPaths: z.array(z.string().min(1)).max(20).default([]),

  meta: z
    .object({
      confidence: z.number().min(0).max(1).default(0.5),
      assumptions: z.array(z.string()).default([]),
      blockers: z.array(z.string()).default([]),
    })
    .default({ confidence: 0.5, assumptions: [], blockers: [] }),
});

export type IntentStrategyDraft = z.infer<typeof IntentStrategyDraftSchema>;
END_FILE
```

---

## 2) Validator (keeps it safe + usable)

```ts
FILE: server/ai/drops/validateIntentStrategyDraft.ts
export type DraftValidationResult = { ok: boolean; errors: string[] };

const TOKEN_PLACEHOLDER_RE = /\b(TODO|TBD|FIXME|PLACEHOLDER)\b|<placeholder>/i;

// Repo file safety: only allow these prefixes
const ALLOWED_PREFIXES = ["client/", "server/", "shared/", "docs/"] as const;

function isSafeRelativePath(p: string): boolean {
  if (!p || typeof p !== "string") return false;
  if (p.startsWith("/") || p.includes("..") || p.includes("\\") || p.includes("\0")) return false;
  return ALLOWED_PREFIXES.some((pref) => p.startsWith(pref));
}

function hasAllHeadings(block: string, headings: string[]): string[] {
  const missing: string[] = [];
  for (const h of headings) {
    const re = new RegExp(`^\\s*##\\s*${h.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\s*$`, "mi");
    if (!re.test(block)) missing.push(h);
  }
  return missing;
}

export function validateIntentStrategyDraft(payload: {
  intentBlock: string;
  strategyBlock: string;
  evidenceRequest: string;
  fileFetchPaths: string[];
}): DraftValidationResult {
  const errors: string[] = [];

  const intent = (payload.intentBlock || "").trim();
  const strategy = (payload.strategyBlock || "").trim();
  const evidence = (payload.evidenceRequest || "").trim();

  if (!intent) errors.push("intentBlock is empty");
  if (!strategy) errors.push("strategyBlock is empty");
  if (!evidence) errors.push("evidenceRequest is empty");

  // Disallow placeholders (keeps it concrete)
  if (TOKEN_PLACEHOLDER_RE.test(intent) || TOKEN_PLACEHOLDER_RE.test(strategy) || TOKEN_PLACEHOLDER_RE.test(evidence)) {
    errors.push("Draft contains placeholder markers (TODO/TBD/FIXME/<placeholder>)");
  }

  // Required headings (keeps it structured)
  const intentMissing = hasAllHeadings(intent, ["Repro Steps", "Expected vs Actual", "Evidence Needed"]);
  if (intentMissing.length) errors.push(`intentBlock missing headings: ${intentMissing.join(", ")}`);

  const strategyMissing = hasAllHeadings(strategy, ["Scope Lock", "Files to Fetch", "Success Criteria"]);
  if (strategyMissing.length) errors.push(`strategyBlock missing headings: ${strategyMissing.join(", ")}`);

  // Validate file paths (best-effort: allow empty list, but validate if provided)
  const paths = Array.isArray(payload.fileFetchPaths) ? payload.fileFetchPaths : [];
  const bad = paths.filter((p) => !isSafeRelativePath(p));
  if (bad.length) {
    errors.push(`fileFetchPaths contains unsafe/invalid paths: ${bad.slice(0, 6).join(", ")}${bad.length > 6 ? "…" : ""}`);
  }

  return { ok: errors.length === 0, errors };
}
END_FILE
```

---

## 3) Skill file: `draftIntentStrategy`

```json
FILE: server/ai/skills/draftIntentStrategy.json
{
  "name": "draftIntentStrategy",
  "description": "Turns a natural-language task into a formal Intent block, a formal Strategy block, a minimal Evidence Request, and a best-guess file fetch list for the target repo.",
  "system_prompt": "You are IntakeScribe. You MUST output JSON ONLY that matches the output schema.\n\nGOAL:\nGiven a natural-language task, draft a formal Intent and Strategy for DreamTeamHub.\n\nHARD RULES:\n1) Output JSON ONLY.\n2) Must include: repo, intentBlock, strategyBlock, evidenceRequest, fileFetchPaths, meta.\n3) intentBlock and strategyBlock must use Markdown headings exactly as specified below.\n4) Do NOT use placeholders (no TODO/TBD/FIXME/<placeholder>).\n5) fileFetchPaths must include only safe relative paths starting with one of: client/, server/, shared/, docs/.\n6) If you are unsure of exact filenames, include fewer paths and put uncertainty into meta.assumptions, and ask for evidence.\n\nINTENT BLOCK FORMAT (must include these headings):\n# Intent (Formal)\n## Repro Steps\n- ...\n## Expected vs Actual\n- Expected: ...\n- Actual: ...\n## Evidence Needed\n- The ONE most important thing to paste from DevTools (Network request details OR console stack) and how to capture it.\n\nSTRATEGY BLOCK FORMAT (must include these headings):\n# Strategy (Formal)\n## Scope Lock\n- What we will change\n- What we will NOT change (no schema changes, no auto-apply, etc.)\n## Files to Fetch\n- Bullet list of file paths to fetch via connector\n## Success Criteria\n- Bullet list of pass/fail checks\n\nEVIDENCE REQUEST:\nA short, single message asking for the exact missing evidence (e.g. failing Network request URL/method/status/response/payload).\n\nMETA:\n- confidence: 0..1\n- assumptions: array of strings\n- blockers: array of strings\n\nReturn JSON ONLY.",
  "input_schema": {
    "type": "object",
    "properties": {
      "taskText": { "type": "string" },
      "repoHint": { "type": "string" },
      "title": { "type": "string" }
    },
    "required": ["taskText"]
  },
  "output_schema": {
    "type": "object",
    "properties": {
      "repo": { "type": "string" },
      "intentBlock": { "type": "string" },
      "strategyBlock": { "type": "string" },
      "evidenceRequest": { "type": "string" },
      "fileFetchPaths": {
        "type": "array",
        "items": { "type": "string" }
      },
      "meta": {
        "type": "object",
        "properties": {
          "confidence": { "type": "number" },
          "assumptions": {
            "type": "array",
            "items": { "type": "string" }
          },
          "blockers": {
            "type": "array",
            "items": { "type": "string" }
          }
        }
      }
    },
    "required": ["repo", "intentBlock", "strategyBlock", "evidenceRequest", "fileFetchPaths", "meta"]
  }
}
END_FILE
```

---

## 4) New Work Item Action endpoint

```ts
FILE: server/routes/workItemActions/draftIntentStrategy.ts
import type { Request, Response } from "express";
import { runSkill } from "../../ai/runSkill";
import { IntentStrategyDraftSchema } from "../../ai/schemas/intentStrategyDraft";
import { validateIntentStrategyDraft } from "../../ai/drops/validateIntentStrategyDraft";

/**
 * Pilot G — Milestone 1 (Draft)
 * POST /api/work-items/:id/actions/draftIntentStrategy
 *
 * Body:
 * {
 *   taskText: string,          // natural language description
 *   repoHint?: string,         // e.g. "GigsterGarage"
 *   title?: string
 * }
 *
 * Returns:
 * 200 { ok:true, ...draft }
 * 400 { ok:false, error, details }
 */
export async function postDraftIntentStrategy(req: Request, res: Response) {
  try {
    const workItemId = req.params.id;
    const { taskText, repoHint, title } = (req.body || {}) as any;

    if (!taskText || typeof taskText !== "string" || taskText.trim().length < 8) {
      return res.status(400).json({
        ok: false,
        error: "taskText is required (a natural-language description of the task).",
      });
    }

    const input = {
      taskText: taskText.trim(),
      repoHint: (repoHint && String(repoHint).trim()) || "GigsterGarage",
      title: (title && String(title).trim()) || `Work Item ${workItemId}`,
    };

    const raw = await runSkill({
      skillName: "draftIntentStrategy",
      input,
    });

    const parsed = IntentStrategyDraftSchema.safeParse(raw);
    if (!parsed.success) {
      return res.status(400).json({
        ok: false,
        error: "Model output did not match IntentStrategyDraft schema",
        details: parsed.error.flatten(),
        rawModelOutput: raw,
      });
    }

    const draft = parsed.data;

    const validation = validateIntentStrategyDraft({
      intentBlock: draft.intentBlock,
      strategyBlock: draft.strategyBlock,
      evidenceRequest: draft.evidenceRequest,
      fileFetchPaths: draft.fileFetchPaths || [],
    });

    if (!validation.ok) {
      return res.status(400).json({
        ok: false,
        error: "Draft failed validation",
        details: { validationErrors: validation.errors },
        draft,
      });
    }

    return res.json({
      ok: true,
      ...draft,
    });
  } catch (err: any) {
    return res.status(500).json({
      ok: false,
      error: err?.message || "Unknown error",
    });
  }
}
END_FILE
```

---

## 5) Wiring note (you’ll add the router line where other actions are mounted)

```md
FILE: server/routes/workItemActions/_pilotG_wiring_note.md
Pilot G — Milestone 1 (Draft) Wiring Note
Confidential and proprietary and copyright Dustin Sparks 2025

You now have:
- server/routes/workItemActions/draftIntentStrategy.ts (exports postDraftIntentStrategy)

Wire it where other Work Item actions are mounted:
POST /api/work-items/:id/actions/draftIntentStrategy -> postDraftIntentStrategy

Body:
{
  "taskText": "Natural language description of the bug/task",
  "repoHint": "GigsterGarage",
  "title": "Optional title"
}

Returns:
{
  ok: true,
  repo,
  intentBlock,
  strategyBlock,
  evidenceRequest,
  fileFetchPaths,
  meta
}
END_FILE
```

---

# How you’ll use Pilot G (right now)

1. Create a Work Item.
2. Call:

`POST /api/work-items/:id/actions/draftIntentStrategy`

Body example:

```json
{
  "repoHint": "GigsterGarage",
  "taskText": "Agency Hub Save shows 'An error occurred' when saving marketing concept and images."
}
```

3. Paste the returned:

* `intentBlock` into Intent
* `strategyBlock` into Strategy
* optionally copy `fileFetchPaths` into your connector fetch list

4. It will also give you a single `evidenceRequest` to answer (usually: failing Network request details).

---

# Pilot G Milestone 1 Definition of Done

* Endpoint returns validated draft blocks from a natural language task
* Draft includes a minimal evidence request
* Draft includes a safe file fetch plan (whitelisted paths only)
* No schema changes; no execution

---

If you paste the router file where `generatePatchDrop` and `generateLifestylePack` were mounted, I’ll give you the exact one-line import + `router.post(...)` patch for wiring `draftIntentStrategy` too.
