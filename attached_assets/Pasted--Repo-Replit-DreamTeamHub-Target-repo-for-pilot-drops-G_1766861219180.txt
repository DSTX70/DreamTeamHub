✅ **Repo/Replit:** **DreamTeamHub**
✅ **Target repo for pilot drops:** **GigsterGarage** (manual apply only — no auto-apply, no VSuiteHQ push yet)

Below is a **paste-ready Replit drop** that adds a **Recommendation → Approval → Drop** pipeline **inside DTH** **without schema changes** by storing stage artifacts in a file-backed store:

* `data/work-item-stages/<workItemId>.json`
* New API:

  * `GET  /api/work-items/:id/stage`
  * `POST /api/work-items/:id/stage/recommendation`
  * `POST /api/work-items/:id/stage/approve`
  * `POST /api/work-items/:id/stage/drop`
* UI on **Work Item detail** (`client/src/pages/work-item-detail.tsx`):

  * Shows “Stage” status
  * Generate recommendation (from Work Item inputs/provenance)
  * Approve recommendation (Dustin approval step)
  * Generate **GigsterGarage** patch drop (FILE/END_FILE format)
  * Copyable output (still non-executing)

---

```diff
FILE: server/lib/workItemStages.ts
+import { promises as fs } from "node:fs";
+import path from "node:path";
+
+export type WorkItemStageName =
+  | "NONE"
+  | "RECOMMENDATION_DRAFT"
+  | "RECOMMENDATION_APPROVED"
+  | "DROP_READY";
+
+export type WorkItemStageRecord = {
+  workItemId: string;
+  stage: WorkItemStageName;
+  created_at: string;
+  updated_at: string;
+  recommendation?: {
+    text: string;
+    created_at: string;
+  };
+  approval?: {
+    approved_by: string;
+    approved_at: string;
+  };
+  drop?: {
+    targetRepo: string;
+    text: string;
+    created_at: string;
+  };
+};
+
+const DATA_DIR = path.join(process.cwd(), "data", "work-item-stages");
+
+async function ensureDir() {
+  await fs.mkdir(DATA_DIR, { recursive: true });
+}
+
+function nowISO() {
+  return new Date().toISOString();
+}
+
+export async function getStage(workItemId: string): Promise<WorkItemStageRecord> {
+  await ensureDir();
+  const p = path.join(DATA_DIR, `${workItemId}.json`);
+  try {
+    const raw = await fs.readFile(p, "utf-8");
+    return JSON.parse(raw) as WorkItemStageRecord;
+  } catch {
+    const base: WorkItemStageRecord = {
+      workItemId,
+      stage: "NONE",
+      created_at: nowISO(),
+      updated_at: nowISO(),
+    };
+    await fs.writeFile(p, JSON.stringify(base, null, 2), "utf-8");
+    return base;
+  }
+}
+
+export async function saveStage(rec: WorkItemStageRecord): Promise<WorkItemStageRecord> {
+  await ensureDir();
+  const next: WorkItemStageRecord = {
+    ...rec,
+    updated_at: nowISO(),
+  };
+  const p = path.join(DATA_DIR, `${rec.workItemId}.json`);
+  await fs.writeFile(p, JSON.stringify(next, null, 2), "utf-8");
+  return next;
+}
+
+export function buildRecommendation(params: {
+  title?: string;
+  inputs?: string;
+  repoHint?: string;
+  strategySessionId?: string | null;
+}): string {
+  const title = params.title || "Untitled Work Item";
+  const repo = params.repoHint || "GigsterGarage";
+  const strategy = params.strategySessionId ? `Strategy Session: ${params.strategySessionId}` : "Strategy Session: (none)";
+
+  return `# Recommendation (Non-executing)\n\n` +
+    `**Target Repo:** ${repo}\n\n` +
+    `**${strategy}**\n\n` +
+    `## What we’re doing\n` +
+    `Convert the locked strategy into an implementation plan for **${repo}**.\n\n` +
+    `## Proposed approach\n` +
+    `1) Confirm the exact files/route(s) in ${repo} impacted by this change.\n` +
+    `2) Implement the smallest additive patch (no refactors) behind safe guards.\n` +
+    `3) Provide post-apply verification steps.\n\n` +
+    `## Inputs (from Work Item)\n` +
+    `\n---\n` +
+    `${(params.inputs || "").trim()}\n` +
+    `\n---\n\n` +
+    `## Approval required\n` +
+    `No drop should be generated or applied until Dustin approves this recommendation.\n`;
+}
+
+export function buildDrop(params: {
+  targetRepo: string;
+  workItemId: string;
+  recommendationText: string;
+}): string {
+  // Non-executing: generate a paste-ready drop template (FILE/END_FILE)
+  // This intentionally does NOT apply anything automatically.
+  return `# Replit Drop (Non-executing)\n` +
+    `# Target Repo: ${params.targetRepo}\n` +
+    `# Source Work Item: ${params.workItemId}\n\n` +
+    `# NOTE: Paste this into the ${params.targetRepo} repo manually.\n\n` +
+    `FILE: README_DTH_DROP_${params.workItemId}.md\n` +
+    `This drop was generated from DTH Work Item ${params.workItemId}.\n\n` +
+    `Recommendation summary:\n` +
+    `${params.recommendationText.slice(0, 1200)}\n\n` +
+    `Next steps:\n- Identify the exact file(s) to patch in ${params.targetRepo}.\n- Replace this placeholder file with real FILE blocks once scope is confirmed.\n` +
+    `END_FILE\n`;
+}
+
END_FILE
```

```diff
FILE: server/routes/workItemStages.ts
+import type { Express } from "express";
+import { buildDrop, buildRecommendation, getStage, saveStage } from "../lib/workItemStages";
+
+export function registerWorkItemStageRoutes(app: Express) {
+  // Read stage record
+  app.get("/api/work-items/:id/stage", async (req, res) => {
+    const rec = await getStage(req.params.id);
+    res.json(rec);
+  });
+
+  // Generate recommendation (non-executing)
+  app.post("/api/work-items/:id/stage/recommendation", async (req, res) => {
+    const workItemId = req.params.id;
+    const rec = await getStage(workItemId);
+
+    const { title, inputs, repoHint, strategySessionId } = req.body || {};
+    const text = buildRecommendation({ title, inputs, repoHint, strategySessionId });
+
+    const next = await saveStage({
+      ...rec,
+      stage: "RECOMMENDATION_DRAFT",
+      recommendation: { text, created_at: new Date().toISOString() },
+    });
+    res.json(next);
+  });
+
+  // Approve recommendation (Dustin gate)
+  app.post("/api/work-items/:id/stage/approve", async (req, res) => {
+    const workItemId = req.params.id;
+    const rec = await getStage(workItemId);
+    if (!rec.recommendation?.text) {
+      return res.status(400).json({ ok: false, error: "No recommendation to approve." });
+    }
+    const approved_by = (req.body?.approved_by as string) || "Dustin Sparks";
+    const next = await saveStage({
+      ...rec,
+      stage: "RECOMMENDATION_APPROVED",
+      approval: { approved_by, approved_at: new Date().toISOString() },
+    });
+    res.json(next);
+  });
+
+  // Generate drop (FILE/END_FILE) for target repo (GigsterGarage default)
+  app.post("/api/work-items/:id/stage/drop", async (req, res) => {
+    const workItemId = req.params.id;
+    const rec = await getStage(workItemId);
+
+    if (rec.stage !== "RECOMMENDATION_APPROVED") {
+      return res.status(400).json({ ok: false, error: "Recommendation must be approved before generating a drop." });
+    }
+
+    const targetRepo = (req.body?.targetRepo as string) || "GigsterGarage";
+    const dropText = buildDrop({
+      targetRepo,
+      workItemId,
+      recommendationText: rec.recommendation?.text || "",
+    });
+
+    const next = await saveStage({
+      ...rec,
+      stage: "DROP_READY",
+      drop: { targetRepo, text: dropText, created_at: new Date().toISOString() },
+    });
+    res.json(next);
+  });
+}
+
END_FILE
```

```diff
FILE: server/routes.ts
@@
+import { registerWorkItemStageRoutes } from "./routes/workItemStages";
@@
 export function registerRoutes(app: any) {
@@
+  // Work Item stage artifacts (Recommendation → Approval → Drop)
+  registerWorkItemStageRoutes(app);
@@
 }
 
 END_FILE
```

---

## UI: add a pipeline card to Work Item detail

This assumes your work item detail already has a `workItem` object loaded (whatever your existing query name is). If your variable is `data`, swap accordingly.

```diff
FILE: client/src/pages/work-item-detail.tsx
@@
 import { useMemo } from "react";
 import { Link } from "wouter";
 import { useQuery, useMutation } from "@tanstack/react-query";
 import { queryClient } from "@/lib/queryClient";
 import { Button } from "@/components/ui/button";
 import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
 import { Badge } from "@/components/ui/badge";
+import { Textarea } from "@/components/ui/textarea";
+import { useToast } from "@/hooks/use-toast";
+import { ArrowRight, Check, FileText, Wand2 } from "lucide-react";
@@
 export default function WorkItemDetailPage() {
+  const { toast } = useToast();
@@
   // workItem is your loaded item (existing)
@@
+  const { data: stage } = useQuery({
+    queryKey: [`/api/work-items/${workItem?.id}/stage`],
+    enabled: !!workItem?.id,
+  });
+
+  const genRec = useMutation({
+    mutationFn: async () => {
+      const res = await fetch(`/api/work-items/${workItem.id}/stage/recommendation`, {
+        method: "POST",
+        headers: { "Content-Type": "application/json" },
+        body: JSON.stringify({
+          title: workItem.title,
+          inputs: workItem.inputs ?? workItem.input ?? "",
+          repoHint: "GigsterGarage",
+          strategySessionId: (() => {
+            // if you already parse strategy provenance from playbook, reuse it here:
+            // otherwise leave null and it will still work
+            return null;
+          })(),
+        }),
+      });
+      if (!res.ok) throw new Error(`Failed (${res.status})`);
+      return res.json();
+    },
+    onSuccess: async () => {
+      await queryClient.invalidateQueries({ queryKey: [`/api/work-items/${workItem.id}/stage`] });
+      toast({ title: "Recommendation generated", description: "Draft created (non-executing)." });
+    },
+  });
+
+  const approveRec = useMutation({
+    mutationFn: async () => {
+      const res = await fetch(`/api/work-items/${workItem.id}/stage/approve`, {
+        method: "POST",
+        headers: { "Content-Type": "application/json" },
+        body: JSON.stringify({ approved_by: "Dustin Sparks" }),
+      });
+      if (!res.ok) throw new Error(`Failed (${res.status})`);
+      return res.json();
+    },
+    onSuccess: async () => {
+      await queryClient.invalidateQueries({ queryKey: [`/api/work-items/${workItem.id}/stage`] });
+      toast({ title: "Approved", description: "Recommendation approved. Drop generation enabled." });
+    },
+  });
+
+  const genDrop = useMutation({
+    mutationFn: async () => {
+      const res = await fetch(`/api/work-items/${workItem.id}/stage/drop`, {
+        method: "POST",
+        headers: { "Content-Type": "application/json" },
+        body: JSON.stringify({ targetRepo: "GigsterGarage" }),
+      });
+      if (!res.ok) throw new Error(`Failed (${res.status})`);
+      return res.json();
+    },
+    onSuccess: async () => {
+      await queryClient.invalidateQueries({ queryKey: [`/api/work-items/${workItem.id}/stage`] });
+      toast({ title: "Drop generated", description: "FILE/END_FILE drop is ready for GigsterGarage." });
+    },
+  });
@@
   return (
     <div className="space-y-4 p-4">
       {/* existing header + provenance badge */}
+
+      <Card>
+        <CardHeader>
+          <CardTitle>Execution Pipeline</CardTitle>
+          <CardDescription>
+            Recommendation → Approval → Drop (non-executing). Target repo: <span className="font-medium">GigsterGarage</span>.
+          </CardDescription>
+        </CardHeader>
+        <CardContent className="space-y-3">
+          <div className="flex flex-wrap gap-2">
+            <Badge variant="outline">Stage: {stage?.stage || "NONE"}</Badge>
+            <Badge variant="secondary">No auto-apply</Badge>
+            <Badge variant="secondary">No VSuiteHQ push</Badge>
+          </div>
+
+          <div className="flex flex-wrap gap-2">
+            <Button
+              onClick={() => genRec.mutate()}
+              disabled={!workItem?.id || genRec.isPending}
+              variant="outline"
+            >
+              <Wand2 className="mr-2 h-4 w-4" />
+              Generate Recommendation
+            </Button>
+
+            <Button
+              onClick={() => approveRec.mutate()}
+              disabled={approveRec.isPending || !(stage?.recommendation?.text)}
+            >
+              <Check className="mr-2 h-4 w-4" />
+              Approve Recommendation
+            </Button>
+
+            <Button
+              onClick={() => genDrop.mutate()}
+              disabled={genDrop.isPending || stage?.stage !== "RECOMMENDATION_APPROVED"}
+              variant="default"
+            >
+              <FileText className="mr-2 h-4 w-4" />
+              Generate GigsterGarage Drop
+            </Button>
+          </div>
+
+          {stage?.recommendation?.text ? (
+            <div className="space-y-1">
+              <div className="text-sm font-medium">Recommendation (Draft)</div>
+              <Textarea value={stage.recommendation.text} readOnly className="min-h-[220px]" />
+            </div>
+          ) : null}
+
+          {stage?.drop?.text ? (
+            <div className="space-y-1">
+              <div className="text-sm font-medium">Replit Drop (Manual apply)</div>
+              <Textarea value={stage.drop.text} readOnly className="min-h-[220px]" />
+              <div className="text-xs text-muted-foreground">
+                Apply by copying this drop into the <span className="font-medium">GigsterGarage</span> repo manually.
+              </div>
+            </div>
+          ) : null}
+        </CardContent>
+      </Card>
 
       {/* rest of your existing detail UI */}
     </div>
   );
 }
 
 END_FILE
```

---

## What this gives you immediately

* DTH can now run the **full controlled loop**:
  **Strategy → Lock → Work Item → Recommendation → Dustin approval → Patch Drop (GigsterGarage)**
* Still **no execution paths** and **no VSuiteHQ handoff** until you choose.

---

## Quick test plan

1. Convert a Strategy Session to a Work Item
2. Open Work Item detail
3. Click **Generate Recommendation**
4. Click **Approve Recommendation**
5. Click **Generate GigsterGarage Drop**
6. Copy drop text and paste into **GigsterGarage** manually

---

## Next step (after you like the flow)

We add **“Open in GigsterGarage”** helper links and (optional) a “Paste Targets” section that tells you *exactly where to paste* in the repo, once the Work Item’s targetContext includes a file/path.
