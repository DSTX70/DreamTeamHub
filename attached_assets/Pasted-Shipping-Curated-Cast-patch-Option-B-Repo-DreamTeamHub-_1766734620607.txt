Shipping Curated-Cast patch (Option B) ✅
Repo: DreamTeamHub (Replit)
Where to paste: replace/update the files below exactly.

This patch adds Auto vs Curated casting on /intent while keeping your sidebar clean and Outcome-first. Curated mode supports:
	•	Pod multi-select (auto-loaded if /api/pods exists; otherwise manual entry)
	•	Persona multi-select (auto-loaded if /api/roles exists; otherwise manual entry)
	•	A Cast Receipt is embedded into the created work item description so the system can generate non-generic, curated outputs downstream.

⸻


FILE: client/src/lib/castingPrefs.ts
const MODE_KEY = "dth_cast_mode"; // "auto" | "curated"
const PODS_KEY = "dth_cast_pods"; // JSON string[]
const PERSONAS_KEY = "dth_cast_personas"; // JSON string[]

export type CastMode = "auto" | "curated";

function safeParseArray(raw: string | null): string[] {
  if (!raw) return [];
  try {
    const v = JSON.parse(raw);
    return Array.isArray(v) ? v.filter((x) => typeof x === "string") : [];
  } catch {
    return [];
  }
}

export function getCastMode(): CastMode {
  try {
    const v = window.localStorage.getItem(MODE_KEY);
    return v === "curated" ? "curated" : "auto";
  } catch {
    return "auto";
  }
}

export function setCastMode(mode: CastMode): void {
  try {
    window.localStorage.setItem(MODE_KEY, mode);
    window.dispatchEvent(new Event("storage"));
  } catch {
    // ignore
  }
}

export function getSelectedPods(): string[] {
  try {
    return safeParseArray(window.localStorage.getItem(PODS_KEY));
  } catch {
    return [];
  }
}

export function setSelectedPods(pods: string[]): void {
  try {
    window.localStorage.setItem(PODS_KEY, JSON.stringify(pods));
    window.dispatchEvent(new Event("storage"));
  } catch {
    // ignore
  }
}

export function getSelectedPersonas(): string[] {
  try {
    return safeParseArray(window.localStorage.getItem(PERSONAS_KEY));
  } catch {
    return [];
  }
}

export function setSelectedPersonas(personas: string[]): void {
  try {
    window.localStorage.setItem(PERSONAS_KEY, JSON.stringify(personas));
    window.dispatchEvent(new Event("storage"));
  } catch {
    // ignore
  }
}
END_FILE

FILE: client/src/hooks/useCastingPrefs.ts
import { useEffect, useState } from "react";
import {
  CastMode,
  getCastMode,
  getSelectedPods,
  getSelectedPersonas,
  setCastMode as persistMode,
  setSelectedPods as persistPods,
  setSelectedPersonas as persistPersonas,
} from "@/lib/castingPrefs";

/**
 * Casting preferences are user-level ergonomics:
 * - Auto: system selects pods/personas
 * - Curated: user selects pods/personas for non-generic outcomes
 *
 * Stored in localStorage; can be upgraded to profile persistence later.
 */
export function useCastingPrefs() {
  const [mode, setModeState] = useState<CastMode>(() => getCastMode());
  const [pods, setPodsState] = useState<string[]>(() => getSelectedPods());
  const [personas, setPersonasState] = useState<string[]>(() => getSelectedPersonas());

  useEffect(() => {
    const onStorage = () => {
      setModeState(getCastMode());
      setPodsState(getSelectedPods());
      setPersonasState(getSelectedPersonas());
    };
    window.addEventListener("storage", onStorage);
    return () => window.removeEventListener("storage", onStorage);
  }, []);

  const setMode = (next: CastMode) => {
    setModeState(next);
    persistMode(next);
  };

  const setPods = (next: string[]) => {
    setPodsState(next);
    persistPods(next);
  };

  const setPersonas = (next: string[]) => {
    setPersonasState(next);
    persistPersonas(next);
  };

  return { mode, setMode, pods, setPods, personas, setPersonas };
}
END_FILE

FILE: client/src/hooks/useCastOptions.ts
import { useQuery } from "@tanstack/react-query";

type Pod = { id?: string; name?: string; title?: string; slug?: string };
type Role = { id?: string; name?: string; title?: string; handle?: string };

async function safeFetchJSON<T>(url: string): Promise<T | null> {
  try {
    const res = await fetch(url, { credentials: "include" });
    if (!res.ok) return null;
    return (await res.json()) as T;
  } catch {
    return null;
  }
}

function normalizeNames(items: any[], keys: string[]): string[] {
  const out: string[] = [];
  for (const it of items || []) {
    if (!it || typeof it !== "object") continue;
    for (const k of keys) {
      const v = (it as any)[k];
      if (typeof v === "string" && v.trim()) {
        out.push(v.trim());
        break;
      }
    }
  }
  // de-dupe
  return Array.from(new Set(out)).sort((a, b) => a.localeCompare(b));
}

/**
 * Best-effort discovery of pods/personas.
 * If endpoints do not exist, UI still works with manual entry.
 */
export function useCastOptions() {
  const podsQ = useQuery({
    queryKey: ["/api/pods"],
    queryFn: async () => {
      const data = await safeFetchJSON<any>("/api/pods");
      if (!data) return { ok: false as const, names: [] as string[] };
      // supports either array payloads or { pods: [] }
      const list = Array.isArray(data) ? data : Array.isArray(data?.pods) ? data.pods : [];
      return { ok: true as const, names: normalizeNames(list, ["name", "title", "slug", "id"]) };
    },
    staleTime: 60_000,
    retry: false,
  });

  const personasQ = useQuery({
    queryKey: ["/api/roles"],
    queryFn: async () => {
      const data = await safeFetchJSON<any>("/api/roles");
      if (!data) return { ok: false as const, names: [] as string[] };
      // supports either array payloads or { roles: [] }
      const list = Array.isArray(data) ? data : Array.isArray(data?.roles) ? data.roles : [];
      return { ok: true as const, names: normalizeNames(list, ["name", "title", "handle", "id"]) };
    },
    staleTime: 60_000,
    retry: false,
  });

  return {
    pods: podsQ.data?.names ?? [],
    podsOk: podsQ.data?.ok ?? false,
    podsLoading: podsQ.isLoading,
    personas: personasQ.data?.names ?? [],
    personasOk: personasQ.data?.ok ?? false,
    personasLoading: personasQ.isLoading,
  };
}
END_FILE

FILE: client/src/pages/intent-console.tsx
import { useMemo, useState } from "react";
import { useMutation } from "@tanstack/react-query";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useLocation } from "wouter";
import { Target, Users, Wand2, X, Search } from "lucide-react";
import { useCastingPrefs } from "@/hooks/useCastingPrefs";
import { useCastOptions } from "@/hooks/useCastOptions";

type Autonomy = "guided" | "standard" | "autonomous";

function buildTitle(intent: string): string {
  const clean = intent.trim().replace(/\s+/g, " ");
  if (!clean) return "New work item";
  return clean.length <= 80 ? clean : `${clean.slice(0, 77)}...`;
}

function joinOrDash(arr: string[]) {
  return arr.length ? arr.join(", ") : "—";
}

function formatCastReceipt(params: {
  mode: "auto" | "curated";
  pods: string[];
  personas: string[];
}) {
  const { mode, pods, personas } = params;
  const lines: string[] = [];
  lines.push("Cast Receipt");
  lines.push(`Mode: ${mode.toUpperCase()}`);
  lines.push(`Pods: ${pods.length ? pods.join(", ") : "AUTO"}`);
  lines.push(`Personas: ${personas.length ? personas.join(", ") : "AUTO"}`);
  return lines.join("\n");
}

function toggleInList(list: string[], value: string): string[] {
  const v = value.trim();
  if (!v) return list;
  return list.includes(v) ? list.filter((x) => x !== v) : [...list, v];
}

export default function IntentConsolePage() {
  const [intent, setIntent] = useState("");
  const [autonomy, setAutonomy] = useState<Autonomy>("standard");
  const { toast } = useToast();
  const [, setLocation] = useLocation();

  const { mode, setMode, pods, setPods, personas, setPersonas } = useCastingPrefs();
  const { pods: podOptions, podsOk, podsLoading, personas: personaOptions, personasOk, personasLoading } = useCastOptions();

  const [podFilter, setPodFilter] = useState("");
  const [personaFilter, setPersonaFilter] = useState("");
  const [manualPods, setManualPods] = useState("");
  const [manualPersonas, setManualPersonas] = useState("");

  const title = useMemo(() => buildTitle(intent), [intent]);

  const effectivePods = useMemo(() => {
    if (mode !== "curated") return [];
    if (podsOk) return pods;
    // manual fallback: split by comma
    return manualPods
      .split(",")
      .map((x) => x.trim())
      .filter(Boolean);
  }, [mode, podsOk, pods, manualPods]);

  const effectivePersonas = useMemo(() => {
    if (mode !== "curated") return [];
    if (personasOk) return personas;
    return manualPersonas
      .split(",")
      .map((x) => x.trim())
      .filter(Boolean);
  }, [mode, personasOk, personas, manualPersonas]);

  const filteredPodOptions = useMemo(() => {
    const q = podFilter.trim().toLowerCase();
    if (!q) return podOptions;
    return podOptions.filter((p) => p.toLowerCase().includes(q));
  }, [podOptions, podFilter]);

  const filteredPersonaOptions = useMemo(() => {
    const q = personaFilter.trim().toLowerCase();
    if (!q) return personaOptions;
    return personaOptions.filter((p) => p.toLowerCase().includes(q));
  }, [personaOptions, personaFilter]);

  const createMutation = useMutation({
    mutationFn: async () => {
      const castReceipt = formatCastReceipt({
        mode,
        pods: effectivePods,
        personas: effectivePersonas,
      });

      const payload = {
        title,
        description:
          (intent
            ? `Intent: ${intent.trim()}\n\nAutonomy: ${autonomy.toUpperCase()}`
            : `Autonomy: ${autonomy.toUpperCase()}`) +
          `\n\n---\n${castReceipt}\n---\n`,
        status: "todo",
        priority: "medium",
      };

      return apiRequest("POST", "/api/work-items", payload);
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["/api/work-items"] });
      await queryClient.invalidateQueries({ queryKey: ["/api/control/dashboard"] });
      toast({
        title: "Queued",
        description:
          mode === "curated"
            ? "Your intent + curated cast were converted into a governed work item."
            : "Your intent was converted into a governed work item.",
      });
      setIntent("");
      setLocation("/work-orders");
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Could not create a work item from that intent.",
        variant: "destructive",
      });
    },
  });

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl font-semibold mb-2" data-testid="page-title">
          Intent
        </h1>
        <p className="text-sm text-muted-foreground">
          Tell the system what you want to accomplish. Choose Auto-Cast for speed, or Curated-Cast when you want truly unique outcomes.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Target className="h-5 w-5" />
            What are you trying to accomplish?
          </CardTitle>
          <CardDescription>
            Outcome-first. You can optionally “cast the orchestra” below.
          </CardDescription>
        </CardHeader>

        <CardContent className="space-y-5">
          <div className="space-y-2">
            <label className="text-sm font-medium">Intent</label>
            <Textarea
              value={intent}
              onChange={(e) => setIntent(e.target.value)}
              placeholder="e.g., Add Curated-Cast to the Intent Console so I can invoke specific pods/personas."
              className="min-h-32"
              data-testid="intent-textarea"
            />
          </div>

          <div className="grid gap-4 md:grid-cols-2">
            <div className="space-y-2">
              <label className="text-sm font-medium">Autonomy</label>
              <Select value={autonomy} onValueChange={(v) => setAutonomy(v as Autonomy)}>
                <SelectTrigger data-testid="intent-autonomy">
                  <SelectValue placeholder="Select" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="guided">Guided</SelectItem>
                  <SelectItem value="standard">Standard</SelectItem>
                  <SelectItem value="autonomous">Autonomous</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <label className="text-sm font-medium">Casting</label>
              <div className="flex gap-2">
                <Button
                  type="button"
                  variant={mode === "auto" ? "default" : "outline"}
                  size="sm"
                  className="gap-2"
                  onClick={() => setMode("auto")}
                  data-testid="cast-auto"
                >
                  <Wand2 className="h-4 w-4" />
                  Auto-Cast
                </Button>
                <Button
                  type="button"
                  variant={mode === "curated" ? "default" : "outline"}
                  size="sm"
                  className="gap-2"
                  onClick={() => setMode("curated")}
                  data-testid="cast-curated"
                >
                  <Users className="h-4 w-4" />
                  Curated-Cast
                </Button>
              </div>
              <p className="text-xs text-muted-foreground">
                Auto-Cast selects the best pods/personas automatically. Curated-Cast lets you pick the cast.
              </p>
            </div>
          </div>

          {/* Curated panel */}
          {mode === "curated" && (
            <div className="rounded-lg border p-4 space-y-4" data-testid="curated-panel">
              <div className="flex items-start justify-between gap-4">
                <div>
                  <div className="font-medium">Curated Cast</div>
                  <div className="text-xs text-muted-foreground">
                    Your selections will be embedded as a Cast Receipt in the work item, so downstream execution stays non-generic.
                  </div>
                </div>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    setPods([]);
                    setPersonas([]);
                    setManualPods("");
                    setManualPersonas("");
                  }}
                  className="gap-2"
                  data-testid="cast-clear"
                >
                  <X className="h-4 w-4" />
                  Clear
                </Button>
              </div>

              {/* Pods */}
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-medium">Pods</label>
                  <span className="text-xs text-muted-foreground">
                    Selected: {podsOk ? pods.length : effectivePods.length}
                  </span>
                </div>

                {podsOk ? (
                  <>
                    <div className="flex items-center gap-2">
                      <Search className="h-4 w-4 text-muted-foreground" />
                      <Input
                        value={podFilter}
                        onChange={(e) => setPodFilter(e.target.value)}
                        placeholder={podsLoading ? "Loading pods…" : "Filter pods…"}
                        data-testid="pods-filter"
                      />
                    </div>

                    <div className="flex flex-wrap gap-2">
                      {filteredPodOptions.slice(0, 60).map((p) => {
                        const selected = pods.includes(p);
                        return (
                          <Badge
                            key={p}
                            variant={selected ? "default" : "secondary"}
                            className="cursor-pointer select-none"
                            onClick={() => setPods(toggleInList(pods, p))}
                            data-testid={`pod-${p}`}
                          >
                            {p}
                          </Badge>
                        );
                      })}
                      {!filteredPodOptions.length && (
                        <div className="text-xs text-muted-foreground">No pods match that filter.</div>
                      )}
                    </div>
                  </>
                ) : (
                  <>
                    <p className="text-xs text-muted-foreground">
                      Pod list endpoint not detected. Enter pods manually (comma-separated).
                    </p>
                    <Input
                      value={manualPods}
                      onChange={(e) => setManualPods(e.target.value)}
                      placeholder="e.g., Prism, Storybloom, Sentinel"
                      data-testid="pods-manual"
                    />
                  </>
                )}
              </div>

              {/* Personas */}
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-medium">Personas</label>
                  <span className="text-xs text-muted-foreground">
                    Selected: {personasOk ? personas.length : effectivePersonas.length}
                  </span>
                </div>

                {personasOk ? (
                  <>
                    <div className="flex items-center gap-2">
                      <Search className="h-4 w-4 text-muted-foreground" />
                      <Input
                        value={personaFilter}
                        onChange={(e) => setPersonaFilter(e.target.value)}
                        placeholder={personasLoading ? "Loading personas…" : "Filter personas…"}
                        data-testid="personas-filter"
                      />
                    </div>

                    <div className="flex flex-wrap gap-2">
                      {filteredPersonaOptions.slice(0, 80).map((p) => {
                        const selected = personas.includes(p);
                        return (
                          <Badge
                            key={p}
                            variant={selected ? "default" : "secondary"}
                            className="cursor-pointer select-none"
                            onClick={() => setPersonas(toggleInList(personas, p))}
                            data-testid={`persona-${p}`}
                          >
                            {p}
                          </Badge>
                        );
                      })}
                      {!filteredPersonaOptions.length && (
                        <div className="text-xs text-muted-foreground">No personas match that filter.</div>
                      )}
                    </div>
                  </>
                ) : (
                  <>
                    <p className="text-xs text-muted-foreground">
                      Persona list endpoint not detected. Enter personas manually (comma-separated).
                    </p>
                    <Input
                      value={manualPersonas}
                      onChange={(e) => setManualPersonas(e.target.value)}
                      placeholder="e.g., Nova, Lume, Aegis"
                      data-testid="personas-manual"
                    />
                  </>
                )}
              </div>

              {/* Preview */}
              <div className="rounded-md bg-muted/40 p-3 text-sm" data-testid="cast-preview">
                <div className="font-medium mb-1">Cast Preview</div>
                <div className="text-xs text-muted-foreground">
                  Pods: {joinOrDash(effectivePods)}
                  <br />
                  Personas: {joinOrDash(effectivePersonas)}
                </div>
              </div>
            </div>
          )}

          <div className="flex items-center gap-3">
            <Button
              onClick={() => createMutation.mutate()}
              disabled={!intent.trim() || createMutation.isPending}
              data-testid="intent-submit"
            >
              Create Work Item
            </Button>
            <Button variant="outline" onClick={() => setLocation("/work-orders")} data-testid="intent-go-work">
              Go to Work
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
END_FILE


⸻

Post-apply verification checklist (Option B)

In DreamTeamHub Replit:
	1.	Typecheck
	•	npm run check
	2.	Run dev
	•	npm run dev
	3.	Manual UX checks
	•	Go to /intent
	•	Confirm you can switch Auto-Cast / Curated-Cast
	•	In Curated mode:
	•	If your backend has /api/pods and /api/roles, chips load and can be selected
	•	If not, the manual comma-entry inputs appear and still work
	•	Create Work Item and confirm it contains a Cast Receipt in description

⸻

If pods/personas don’t auto-load

That’s expected if your API routes are named differently. Paste the actual endpoints you have (or the server routes file that defines them) and I’ll do a tiny follow-up patch to point useCastOptions() at the correct URLs (still Option B, still DreamTeamHub repo).