Locked. Here’s the **one-button flow** patch that does:

**Draft (Pilot G) → parse fileFetchPaths → fetch files via GG connector → build evidenceNotes → create Strategy → create Work Item → auto-attach evidenceNotes → open Work Item**

**Repo:** ✅ **DreamTeamHub**
**File:** `client/src/pages/intent-console.tsx`

---

## Patch drop — One-button end-to-end flow

FILE: client/src/pages/intent-console.tsx

```tsx
// ============================
// 1) Add/ensure these imports
// ============================
// Add only what’s missing in your file.
import React, { useEffect, useMemo, useRef, useState } from "react";

// ============================
// 2) Add a ref for latest GG base url (optional but nice in evidence header)
// ============================
// You already have ggMetaBaseUrl state. Add this ref + sync effect near your other refs.
const ggBaseUrlRef = useRef<string | undefined>(undefined);

useEffect(() => {
  ggBaseUrlRef.current = ggMetaBaseUrl;
}, [ggMetaBaseUrl]);

// ============================
// 3) Add a helper to fetch files via connector (returns normalized files)
// ============================
// Place near your other helpers inside the component (or above if you prefer).
async function fetchFilesViaConnector(paths: string[]): Promise<FetchedFile[]> {
  const r = await fetch("/api/connectors/gigsterGarage/files", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    credentials: "include",
    body: JSON.stringify({
      paths,
      pathsText: paths.join("\n"),
    }),
  });

  if (!r.ok) {
    const t = await r.text();
    throw new Error(`Connector fetch failed (${r.status}): ${t}`);
  }

  const j = await r.json();
  return normalizeFilesResponse(j);
}

// ============================
// 4) Add a helper to append evidenceNotes to a specific work item (no prompt)
// ============================
// (You already have appendEvidenceToWorkItemId() using refs; this variant takes a string explicitly.)
async function appendEvidenceNotesToWorkItem(workItemId: number, evidenceNotesText: string) {
  const block = String(evidenceNotesText || "").trim();
  if (!block) return { ok: false, skipped: true as const, reason: "empty_evidence" };

  const r = await fetch(`/api/work-items/${workItemId}/actions/appendEvidenceNotes`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    credentials: "include",
    body: JSON.stringify({ evidenceNotes: block }),
  });

  if (!r.ok) {
    const t = await r.text();
    throw new Error(`Auto-attach failed (${r.status}): ${t}`);
  }

  return { ok: true, skipped: false as const };
}

// ============================
// 5) NEW mutation: Draft → Fetch → Create → Attach → Open
// ============================
// Replace the onClick for your existing “Draft → Create Work Item + Strategy → Open Work Item”
// button to call this mutation instead of the older draftCreateAllMutation.

const draftFetchCreateAllMutation = useMutation({
  mutationFn: async () => {
    if (!intent.trim()) throw new Error("Intent is empty");

    // Step 1: Draft Intent + Strategy (Pilot G)
    const draftRes = await fetch(`/api/work-items/0/actions/draftIntentStrategy`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "include",
      body: JSON.stringify({
        taskText: intent.trim(),
        repoHint: targetContext || "GigsterGarage",
        title,
      }),
    });

    const draftJson = await draftRes.json().catch(() => null);
    if (!draftRes.ok || !draftJson?.ok) {
      throw new Error(draftJson?.error || `Draft failed (${draftRes.status})`);
    }
    const draftData = draftJson as IntentStrategyDraft;

    // Step 1.5: Parse suggested paths + fetch files (via DTH→GG connector)
    const paths = coerceSuggestedPaths(draftData);
    let fetched: FetchedFile[] = [];
    let fetchOk = false;
    let fetchError: string | null = null;

    if (paths.length > 0) {
      try {
        fetched = await fetchFilesViaConnector(paths);
        fetchOk = true;
      } catch (e: any) {
        fetchError = e?.message || "File fetch failed";
      }
    }

    // Build evidence block NOW (even if partial fetch; it will include failures)
    const evidenceText =
      fetched.length > 0
        ? buildEvidenceBlock(ggBaseUrlRef.current, fetched)
        : paths.length > 0 && fetchError
          ? [
              "## GigsterGarage Evidence Pack (Fetch Failed)",
              ggBaseUrlRef.current ? `Base URL: ${ggBaseUrlRef.current}` : "",
              `Fetched at: ${new Date().toISOString()}`,
              "",
              `Paths requested:`,
              ...paths.map((p) => `- ${p}`),
              "",
              `Fetch error: ${fetchError}`,
              "",
            ].filter(Boolean).join("\n")
          : "";

    // Step 2: Create Strategy Session from draft
    const strategyBody = formatDraftIntoStrategyBody(draftData);
    const strategyRes = await fetch("/api/strategy-sessions", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "include",
      body: JSON.stringify({
        title: `Strategy Session — ${title}`,
        author: "Dustin Sparks",
        approval_required_for_execution: true,
        repo_hint: draftData.repo || targetContext || "GigsterGarage",
        bodyMd: strategyBody,
      }),
    });

    const strategyJson = await strategyRes.json().catch(() => null);
    if (!strategyRes.ok) {
      throw new Error(strategyJson?.error || `Strategy creation failed (${strategyRes.status})`);
    }
    const strategyData = strategyJson as StrategySession;

    // Step 3: Create Work Item with reference to strategy
    const castReceipt = formatCastReceipt({ /* ... your existing payload ... */ });
    const workItemPayload = {
      title,
      description:
        `Intent: ${draftData.intentBlock.trim()}\n\n` +
        `Strategy Session: /strategy/${strategyData.id}\n\n` +
        `Autonomy: ${autonomy.toUpperCase()}\n\n---\n${castReceipt}\n---\n`,
      status: "todo",
      priority: "medium",
    };

    const workItemRes = await apiRequest("POST", "/api/work-items", workItemPayload);
    const workItemData = await workItemRes.json();

    // Step 4: Auto-attach evidenceNotes (only if we have an evidenceText)
    let evidenceAutoAttached = false;
    if (String(evidenceText || "").trim().length > 0) {
      await appendEvidenceNotesToWorkItem(workItemData.id, evidenceText);
      evidenceAutoAttached = true;
    }

    return {
      draft: draftData,
      strategy: strategyData,
      workItem: workItemData,
      suggestedPaths: paths,
      fetchedFiles: fetched,
      fetchOk,
      fetchError,
      evidenceAutoAttached,
    };
  },

  onSuccess: async (result) => {
    await queryClient.invalidateQueries({ queryKey: ["/api/work-items"] });
    await queryClient.invalidateQueries({ queryKey: ["/api/strategy-sessions"] });
    await queryClient.invalidateQueries({ queryKey: ["/api/control/dashboard"] });

    // Keep your existing UX resets
    setIntent("");
    setDraft(null);

    // Update UI state (useful if user stays on console or returns)
    setSuggestedPaths(result.suggestedPaths || []);
    setFetchedFiles(result.fetchedFiles || []);
    setActiveWorkItemId(result.workItem.id);

    toast({
      title: "All created",
      description: result.evidenceAutoAttached
        ? "Draft → Fetch Files → Strategy → Work Item. Evidence auto-attached. Opening…"
        : (result.suggestedPaths?.length
            ? "Draft → Fetch Files → Strategy → Work Item. (Evidence not attached—see fetch status.) Opening…"
            : "Draft → Strategy → Work Item. (No suggested files.) Opening…"),
    });

    setLocation(`/work-items/${result.workItem.id}`);
  },

  onError: (err: any) => {
    toast({
      title: "All-in-one failed",
      description: err?.message || "Unknown error",
      variant: "destructive",
    });
  },
});

// ============================
// 6) Wire your existing button to call the new mutation
// ============================
// Wherever you render the “Draft → Create Work Item + Strategy → Open Work Item” button,
// change its onClick to:
//
/*
onClick={() => draftFetchCreateAllMutation.mutate()}
disabled={draftFetchCreateAllMutation.isPending}
*/
// and update label if you want:
//
/*
{draftFetchCreateAllMutation.isPending ? "Working…" : "Draft → Fetch → Create + Attach → Open Work Item"}
*/
```

END_FILE

---

## What to change in the UI (1 line)

Find the existing “All-in-one” button (you noted around line ~516) and point it to the new mutation:

```tsx
onClick={() => draftFetchCreateAllMutation.mutate()}
```

Label suggestion:
**“Draft → Fetch → Create + Attach → Open Work Item”**

---

## Ship

```bash
git add client/src/pages/intent-console.tsx
git commit -m "DTH: one-button Draft→Fetch→Create→Attach→Open flow"
git push origin main
```

---

## DoD check

* One click produces a Work Item with `evidenceNotes` already appended (when suggested paths exist).
* If no suggested paths → still creates work item (no attach).
* If file fetch fails → work item still created; evidence will include fetch failure block (so Pilot F has traceability).

If you want the button to **hard-fail** when file fetch fails (instead of continuing), say so and I’ll flip that behavior.
