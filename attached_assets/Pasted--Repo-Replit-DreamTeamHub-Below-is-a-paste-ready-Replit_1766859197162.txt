✅ **Repo/Replit:** **DreamTeamHub**
Below is a **paste-ready Replit drop** that adds **Strategy Sessions (non-executing)** as a first-class, persistent artifact in DTH, with:

* **API**: `/api/strategy-sessions` CRUD (file-backed JSON; **no schema changes**)
* **UI**: `/strategy` list + `/strategy/:id` detail (wouter + tanstack query patterns)
* **Default template** seeded from your `DTH_STRATEGY_SESSION_INIT.md` content
* **Explicit “Lock Direction”** action (sets status to `LOCKED`, records `locked_at`)
* **Hard rule**: Strategy Sessions are **NON_EXECUTING** (no drops, no apply, no ingest)

---

```diff
FILE: server/lib/strategySessions.ts
+import { promises as fs } from "node:fs";
+import path from "node:path";
+import crypto from "node:crypto";
+
+export type StrategySessionStatus = "OPEN" | "LOCKED" | "ARCHIVED";
+
+export type StrategySession = {
+  id: string;
+  title: string;
+  status: StrategySessionStatus;
+  mode: "STRATEGY / BRAINSTORM (NON-EXECUTING)";
+  author: string;
+  approval_required_for_execution: boolean;
+  repo_hint?: string;
+  goal?: string;
+  participants?: string[];
+  questions?: string[];
+  bodyMd: string;
+  created_at: string;
+  updated_at: string;
+  locked_at?: string;
+};
+
+const DATA_DIR = path.join(process.cwd(), "data", "strategy-sessions");
+
+async function ensureDir() {
+  await fs.mkdir(DATA_DIR, { recursive: true });
+}
+
+function nowISO() {
+  return new Date().toISOString();
+}
+
+export function defaultStrategySessionBody(): string {
+  return `TITLE: Dream Team Hub — Strategy Session v1.0 (Pre-Execution)
+
+STATUS: OPEN
+MODE: STRATEGY / BRAINSTORM (NON-EXECUTING)
+
+AUTHOR: Dustin Sparks
+APPROVAL_REQUIRED_FOR_EXECUTION: true
+
+---
+
+## PURPOSE
+
+This Strategy Session exists to:
+- Clarify intent before solutions
+- Explore ideas, tradeoffs, and risks
+- Refine *what problem we are actually solving*
+- Prevent premature recommendations, code, or drops
+
+This session is explicitly **non-executing**.
+
+---
+
+## SCOPE & RULES
+
+Allowed:
+- Brainstorming
+- Debate and disagreement
+- Option exploration
+- Risk identification
+- Clarifying questions
+- Directional thinking
+
+Not Allowed:
+- ❌ Code drops
+- ❌ Repo changes
+- ❌ Replit handoff
+- ❌ Shipping, ingest, or apply actions
+
+No outputs from this session may be executed without an explicit **Strategy Lock** and subsequent approval.
+
+---
+
+## CONTEXT
+
+Project / Repo:
+- Gigster Garage (pilot candidate)
+
+Goal:
+- Define the correct workflow and boundaries for agents + repos doing real work together
+- Ensure Dustin Sparks remains the sole approval authority
+- Establish the clean separation between:
+  Strategy → Recommendations → Execution
+
+Constraints:
+- Safety over speed
+- No silent execution paths
+- Human approval must be enforceable, not implied
+
+---
+
+## PARTICIPANTS (INVITED)
+
+- OS (Orchestration)
+- Forge (Architecture)
+- LexiCode (Implementation realism)
+- Lume (UX / flow)
+- Sentinel (Risk & safety)
+- Aegis (Governance / control points)
+- Sparkster (Clarity of intent & language)
+
+---
+
+## QUESTIONS TO ADDRESS
+
+1. What *must* happen before any recommendation or drop is allowed?
+2. What is the minimum approval artifact that blocks execution?
+3. Which tasks require a Strategy Session vs fast-path execution?
+4. Where do Strategy Sessions end and Work Orders begin?
+5. What information must survive as a permanent artifact?
+
+---
+
+## EXIT CRITERIA
+
+This session remains OPEN until:
+- A clear direction is agreed upon
+- Dustin Sparks issues a **Strategy Lock**
+
+Only after a Strategy Lock may recommendations or execution artifacts be created.
+`;
+}
+
+export async function listStrategySessions(): Promise<StrategySession[]> {
+  await ensureDir();
+  const files = await fs.readdir(DATA_DIR);
+  const sessions: StrategySession[] = [];
+  for (const f of files) {
+    if (!f.endsWith(".json")) continue;
+    const raw = await fs.readFile(path.join(DATA_DIR, f), "utf-8");
+    try {
+      sessions.push(JSON.parse(raw));
+    } catch {
+      // ignore corrupt file
+    }
+  }
+  // newest first
+  sessions.sort((a, b) => (b.updated_at || "").localeCompare(a.updated_at || ""));
+  return sessions;
+}
+
+export async function getStrategySession(id: string): Promise<StrategySession | null> {
+  await ensureDir();
+  const p = path.join(DATA_DIR, `${id}.json`);
+  try {
+    const raw = await fs.readFile(p, "utf-8");
+    return JSON.parse(raw);
+  } catch {
+    return null;
+  }
+}
+
+export async function createStrategySession(input: Partial<StrategySession>): Promise<StrategySession> {
+  await ensureDir();
+  const id = input.id || crypto.randomBytes(8).toString("hex");
+  const created_at = nowISO();
+  const updated_at = created_at;
+  const session: StrategySession = {
+    id,
+    title: input.title || "Dream Team Hub — Strategy Session (Pre-Execution)",
+    status: "OPEN",
+    mode: "STRATEGY / BRAINSTORM (NON-EXECUTING)",
+    author: input.author || "Dustin Sparks",
+    approval_required_for_execution: input.approval_required_for_execution ?? true,
+    repo_hint: input.repo_hint,
+    goal: input.goal,
+    participants: input.participants || [
+      "OS",
+      "Forge",
+      "LexiCode",
+      "Lume",
+      "Sentinel",
+      "Aegis",
+      "Sparkster",
+    ],
+    questions: input.questions || [
+      "What must happen before any recommendation or drop is allowed?",
+      "What is the minimum approval artifact that blocks execution?",
+      "Which tasks require a Strategy Session vs fast-path execution?",
+      "Where do Strategy Sessions end and Work Orders begin?",
+      "What information must survive as a permanent artifact?",
+    ],
+    bodyMd: input.bodyMd || defaultStrategySessionBody(),
+    created_at,
+    updated_at,
+  };
+  await fs.writeFile(path.join(DATA_DIR, `${id}.json`), JSON.stringify(session, null, 2), "utf-8");
+  return session;
+}
+
+export async function updateStrategySession(id: string, patch: Partial<StrategySession>): Promise<StrategySession | null> {
+  const existing = await getStrategySession(id);
+  if (!existing) return null;
+
+  const next: StrategySession = {
+    ...existing,
+    ...patch,
+    id: existing.id,
+    mode: "STRATEGY / BRAINSTORM (NON-EXECUTING)", // non-negotiable
+    updated_at: nowISO(),
+  };
+
+  // Lock semantics
+  if (patch.status === "LOCKED" && !existing.locked_at) {
+    next.locked_at = nowISO();
+  }
+
+  await fs.writeFile(path.join(DATA_DIR, `${id}.json`), JSON.stringify(next, null, 2), "utf-8");
+  return next;
+}
+
+export async function deleteStrategySession(id: string): Promise<boolean> {
+  await ensureDir();
+  const p = path.join(DATA_DIR, `${id}.json`);
+  try {
+    await fs.unlink(p);
+    return true;
+  } catch {
+    return false;
+  }
+}
+
END_FILE
```

```diff
FILE: server/routes/strategySessions.ts
+import type { Express } from "express";
+import {
+  createStrategySession,
+  deleteStrategySession,
+  getStrategySession,
+  listStrategySessions,
+  updateStrategySession,
+} from "../lib/strategySessions";
+
+export function registerStrategySessionRoutes(app: Express) {
+  // List
+  app.get("/api/strategy-sessions", async (_req, res) => {
+    const sessions = await listStrategySessions();
+    res.json(sessions);
+  });
+
+  // Create
+  app.post("/api/strategy-sessions", async (req, res) => {
+    const session = await createStrategySession(req.body || {});
+    res.json(session);
+  });
+
+  // Read
+  app.get("/api/strategy-sessions/:id", async (req, res) => {
+    const s = await getStrategySession(req.params.id);
+    if (!s) return res.status(404).json({ ok: false, error: "Not found" });
+    res.json(s);
+  });
+
+  // Update
+  app.put("/api/strategy-sessions/:id", async (req, res) => {
+    const s = await updateStrategySession(req.params.id, req.body || {});
+    if (!s) return res.status(404).json({ ok: false, error: "Not found" });
+    res.json(s);
+  });
+
+  // Delete (rare; mainly for cleanup)
+  app.delete("/api/strategy-sessions/:id", async (req, res) => {
+    const ok = await deleteStrategySession(req.params.id);
+    res.json({ ok });
+  });
+}
+
END_FILE
```

```diff
FILE: server/routes.ts
@@
+import { registerStrategySessionRoutes } from "./routes/strategySessions";
@@
 export function registerRoutes(app: any) {
@@
+  // Strategy Sessions (NON-EXECUTING)
+  registerStrategySessionRoutes(app);
@@
 }
 
 END_FILE
```

---

## UI

```diff
FILE: client/src/pages/strategy/strategy-list.tsx
+import { useMemo } from "react";
+import { Link, useLocation } from "wouter";
+import { useMutation, useQuery } from "@tanstack/react-query";
+import { Button } from "@/components/ui/button";
+import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
+import { Badge } from "@/components/ui/badge";
+import { Plus } from "lucide-react";
+import { queryClient } from "@/lib/queryClient";
+
+type StrategySession = {
+  id: string;
+  title: string;
+  status: "OPEN" | "LOCKED" | "ARCHIVED";
+  mode: string;
+  author: string;
+  approval_required_for_execution: boolean;
+  created_at: string;
+  updated_at: string;
+  locked_at?: string;
+};
+
+export default function StrategyListPage() {
+  const [, setLocation] = useLocation();
+
+  const { data: sessions = [], isLoading, error } = useQuery<StrategySession[]>({
+    queryKey: ["/api/strategy-sessions"],
+    refetchInterval: 8000,
+  });
+
+  const createMutation = useMutation({
+    mutationFn: async () => {
+      const res = await fetch("/api/strategy-sessions", {
+        method: "POST",
+        headers: { "Content-Type": "application/json" },
+        body: JSON.stringify({
+          title: "Dream Team Hub — Strategy Session v1.0 (Pre-Execution)",
+          author: "Dustin Sparks",
+          approval_required_for_execution: true,
+          repo_hint: "Gigster Garage (pilot candidate)",
+        }),
+      });
+      if (!res.ok) throw new Error(`Failed to create (${res.status})`);
+      return (await res.json()) as StrategySession;
+    },
+    onSuccess: async (s) => {
+      await queryClient.invalidateQueries({ queryKey: ["/api/strategy-sessions"] });
+      setLocation(`/strategy/${s.id}`);
+    },
+  });
+
+  const counts = useMemo(() => {
+    const open = sessions.filter((s) => s.status === "OPEN").length;
+    const locked = sessions.filter((s) => s.status === "LOCKED").length;
+    return { open, locked, total: sessions.length };
+  }, [sessions]);
+
+  return (
+    <div className="space-y-4 p-4">
+      <Card>
+        <CardHeader>
+          <div className="flex items-start justify-between gap-3">
+            <div>
+              <CardTitle>Strategy Sessions</CardTitle>
+              <CardDescription>
+                Think in DTH. This space is <span className="font-medium">NON-EXECUTING</span> — no drops, no repo changes.
+              </CardDescription>
+            </div>
+            <div className="flex gap-2">
+              <Badge variant="secondary">Open: {counts.open}</Badge>
+              <Badge variant="secondary">Locked: {counts.locked}</Badge>
+            </div>
+          </div>
+        </CardHeader>
+        <CardContent className="flex flex-wrap items-center justify-between gap-2">
+          <div className="text-sm text-muted-foreground">
+            Total sessions: <span className="font-medium">{counts.total}</span>
+          </div>
+          <Button onClick={() => createMutation.mutate()} disabled={createMutation.isPending}>
+            <Plus className="mr-2 h-4 w-4" />
+            New Strategy Session
+          </Button>
+        </CardContent>
+      </Card>
+
+      {isLoading ? <div className="text-sm text-muted-foreground">Loading…</div> : null}
+      {error ? <div className="rounded-md border p-3 text-sm">Failed to load strategy sessions.</div> : null}
+
+      <div className="space-y-2">
+        {sessions.map((s) => (
+          <Link key={s.id} href={`/strategy/${s.id}`}>
+            <Card className="p-4 hover:bg-muted/40">
+              <div className="flex flex-col gap-2 md:flex-row md:items-start md:justify-between">
+                <div className="min-w-0">
+                  <div className="truncate font-medium">{s.title}</div>
+                  <div className="text-xs text-muted-foreground">
+                    {s.id} • {s.author}
+                  </div>
+                </div>
+                <div className="flex flex-wrap items-center gap-2">
+                  <Badge variant={s.status === "OPEN" ? "default" : "secondary"}>{s.status}</Badge>
+                  <Badge variant="outline">NON-EXECUTING</Badge>
+                </div>
+              </div>
+            </Card>
+          </Link>
+        ))}
+        {sessions.length === 0 && !isLoading ? (
+          <Card className="p-6 text-sm text-muted-foreground">
+            No Strategy Sessions yet. Create one to start a non-executing brainstorm.
+          </Card>
+        ) : null}
+      </div>
+    </div>
+  );
+}
+
END_FILE
```

```diff
FILE: client/src/pages/strategy/strategy-detail.tsx
+import { useMemo, useState } from "react";
+import { useLocation, useRoute } from "wouter";
+import { useMutation, useQuery } from "@tanstack/react-query";
+import { queryClient } from "@/lib/queryClient";
+import { Button } from "@/components/ui/button";
+import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
+import { Input } from "@/components/ui/input";
+import { Textarea } from "@/components/ui/textarea";
+import { Badge } from "@/components/ui/badge";
+import { useToast } from "@/hooks/use-toast";
+import { Lock, Save, Trash2 } from "lucide-react";
+
+type StrategySession = {
+  id: string;
+  title: string;
+  status: "OPEN" | "LOCKED" | "ARCHIVED";
+  mode: "STRATEGY / BRAINSTORM (NON-EXECUTING)";
+  author: string;
+  approval_required_for_execution: boolean;
+  repo_hint?: string;
+  goal?: string;
+  participants?: string[];
+  questions?: string[];
+  bodyMd: string;
+  created_at: string;
+  updated_at: string;
+  locked_at?: string;
+};
+
+export default function StrategyDetailPage() {
+  const { toast } = useToast();
+  const [, setLocation] = useLocation();
+  const [, params] = useRoute("/strategy/:id");
+  const id = params?.id as string;
+
+  const { data, isLoading, error } = useQuery<StrategySession>({
+    queryKey: [`/api/strategy-sessions/${id}`],
+  });
+
+  const [localTitle, setLocalTitle] = useState("");
+  const [localBody, setLocalBody] = useState("");
+
+  // initialize local state when data arrives
+  useMemo(() => {
+    if (!data) return;
+    setLocalTitle(data.title);
+    setLocalBody(data.bodyMd);
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, [data?.id]);
+
+  const saveMutation = useMutation({
+    mutationFn: async () => {
+      const res = await fetch(`/api/strategy-sessions/${id}`, {
+        method: "PUT",
+        headers: { "Content-Type": "application/json" },
+        body: JSON.stringify({ title: localTitle, bodyMd: localBody }),
+      });
+      if (!res.ok) throw new Error(`Save failed (${res.status})`);
+      return (await res.json()) as StrategySession;
+    },
+    onSuccess: async () => {
+      await queryClient.invalidateQueries({ queryKey: [`/api/strategy-sessions/${id}`] });
+      await queryClient.invalidateQueries({ queryKey: ["/api/strategy-sessions"] });
+      toast({ title: "Saved", description: "Strategy Session updated." });
+    },
+  });
+
+  const lockMutation = useMutation({
+    mutationFn: async () => {
+      const res = await fetch(`/api/strategy-sessions/${id}`, {
+        method: "PUT",
+        headers: { "Content-Type": "application/json" },
+        body: JSON.stringify({ status: "LOCKED" }),
+      });
+      if (!res.ok) throw new Error(`Lock failed (${res.status})`);
+      return (await res.json()) as StrategySession;
+    },
+    onSuccess: async () => {
+      await queryClient.invalidateQueries({ queryKey: [`/api/strategy-sessions/${id}`] });
+      await queryClient.invalidateQueries({ queryKey: ["/api/strategy-sessions"] });
+      toast({ title: "Locked", description: "Direction locked. Execution still requires explicit approval." });
+    },
+  });
+
+  const deleteMutation = useMutation({
+    mutationFn: async () => {
+      const res = await fetch(`/api/strategy-sessions/${id}`, { method: "DELETE" });
+      if (!res.ok) throw new Error(`Delete failed (${res.status})`);
+      return (await res.json()) as { ok: boolean };
+    },
+    onSuccess: async () => {
+      await queryClient.invalidateQueries({ queryKey: ["/api/strategy-sessions"] });
+      toast({ title: "Deleted", description: "Strategy Session removed." });
+      setLocation("/strategy");
+    },
+  });
+
+  if (isLoading) return <div className="p-4 text-sm text-muted-foreground">Loading…</div>;
+  if (error || !data) return <div className="p-4 text-sm">Not found.</div>;
+
+  return (
+    <div className="space-y-4 p-4">
+      <Card>
+        <CardHeader>
+          <div className="flex items-start justify-between gap-3">
+            <div>
+              <CardTitle>{data.title}</CardTitle>
+              <CardDescription>
+                <span className="font-medium">NON-EXECUTING</span> brainstorm space. No code drops or repo changes.
+              </CardDescription>
+            </div>
+            <div className="flex flex-wrap gap-2">
+              <Badge variant={data.status === "OPEN" ? "default" : "secondary"}>{data.status}</Badge>
+              <Badge variant="outline">Strategy</Badge>
+            </div>
+          </div>
+        </CardHeader>
+        <CardContent className="flex flex-wrap gap-2">
+          <Button onClick={() => saveMutation.mutate()} disabled={saveMutation.isPending}>
+            <Save className="mr-2 h-4 w-4" /> Save
+          </Button>
+          <Button
+            variant="outline"
+            onClick={() => lockMutation.mutate()}
+            disabled={lockMutation.isPending || data.status === "LOCKED"}
+            title="Locks direction; execution still requires approval in Work Items."
+          >
+            <Lock className="mr-2 h-4 w-4" /> Lock Direction
+          </Button>
+          <Button
+            variant="destructive"
+            onClick={() => deleteMutation.mutate()}
+            disabled={deleteMutation.isPending}
+            title="Delete session"
+          >
+            <Trash2 className="mr-2 h-4 w-4" /> Delete
+          </Button>
+        </CardContent>
+      </Card>
+
+      <Card>
+        <CardHeader>
+          <CardTitle>Edit Session</CardTitle>
+          <CardDescription>Update the title and the session body. Lock when ready.</CardDescription>
+        </CardHeader>
+        <CardContent className="space-y-3">
+          <div className="space-y-1">
+            <div className="text-sm font-medium">Title</div>
+            <Input value={localTitle} onChange={(e) => setLocalTitle(e.target.value)} />
+          </div>
+          <div className="space-y-1">
+            <div className="text-sm font-medium">Body (Markdown)</div>
+            <Textarea value={localBody} onChange={(e) => setLocalBody(e.target.value)} className="min-h-[420px]" />
+          </div>
+        </CardContent>
+      </Card>
+    </div>
+  );
+}
+
END_FILE
```

---

## Wire routes (wouter)

> Your `client/src/App.tsx` is using wouter. Add these two routes.
> (If you already have a Switch/Route block, insert them near other top-level routes.)

```diff
FILE: client/src/App.tsx
@@
+import StrategyListPage from "@/pages/strategy/strategy-list";
+import StrategyDetailPage from "@/pages/strategy/strategy-detail";
@@
   // inside your <Switch> (or route map)
+  <Route path="/strategy" component={StrategyListPage} />
+  <Route path="/strategy/:id" component={StrategyDetailPage} />
 
 END_FILE
```

---

## Optional: Sidebar entry (safe if you have a nav items array)

If your sidebar is data-driven, add an item:

* label: **Strategy**
* href: **/strategy**

I’m not editing `app-sidebar.tsx` here because structures vary; if you paste the nav items array (10–40 lines), I’ll give you an exact diff.

---

# Post-apply verification checklist

1. Load `/strategy`

   * Create session → navigates to `/strategy/:id`
2. Edit title/body → Save
3. Click **Lock Direction**

   * status becomes LOCKED
4. Refresh page

   * changes persist (file-backed JSON)
5. Confirm: no code drops / no apply / no ingest anywhere in this flow

---

## Next implementation step (once this is live)

After Strategy Sessions are working, we can add:

* “Convert to Work Item” (creates a Work Item stub **without executing**)
* “Strategy Lock → enables recommendations” gate in the Work Item flow
* Only then: optional push to VSuiteHQ

If you want, I’ll generate the **next patch** to add “Convert to Work Item” as a one-click action from a locked Strategy Session.
